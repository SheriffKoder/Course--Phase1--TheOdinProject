
/*
////2D Transforms

Almost all elements can have the transform property applied to it, 
with the exceptions being <col>, <colgroup>, and non-replaced inline elements. 

“Non-replaced” simply refers to elements whose content is contained within the HTML 
document (<span>, <b>, and <em>, for example), 

as opposed to a “replaced” element’s content being contained outside of the document 
(<a>, <iframe>, and <img>, for example).


rotate, scale, skew, translate




*/

.margin {
    margin: 0 0 100px 100px;
}

.box {
    background: black;
    height: 100px;
    width: 100px;
}

.skewXY {
    /* X and Y values respectively, if one then its X 
    also skewX, skewY separately */
    transform: skew(45deg, -0.5rad);

}


.mainContainer {
    height: 200px;
    width: 200px;
    border: 1px solid black;

    display: flex;
    align-items: center;
    justify-content: center;

    margin: 0 0 100px 100px;

}

.TranslateXY {
    transform: translate(20px, -33%);
}


/* order of chain will affect the display, 
as these two chains have the same values but different order 
composite transforms are effectively applied in order from right to left.

When an element is rotated before being translated, 
the translate direction is on the rotated axis.

transformation are always in the position defined by transform-origin 
(by default the center of the element)

the other difference with the left to right version is 
that you use a fixed system of coordinates/angles.

consider making use of the prefers-reduced-motion media feature — 
use it to write a media query that will turn off animations if the user 
has reduced animation specified in their system preferences.

*/

.TranslateChain1 {
    transform: skew(45deg, -0.5rad) translate(20px, 33%);
}


.TranslateChain2 {
    transform: translate(20px, 33%) skew(45deg, -0.5rad) ;
}




/* transformation example of ltr and rtl
The left element is using a left to right progression and the right one a right 
to left progression. Note how the corners of the left one are following 
an elliptical path and how the shape is not preserved during the rotation.
*/
.object
{
  width: 100px; height: 100px;
  background: rgb(114,34,34);
  animation: ltr 5s infinite;
}
.object2 {
    animation-name: rtl;
}

@keyframes ltr
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(.5) rotate( 0deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}
@keyframes rtl
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(1 ) rotate(45deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}



/*
//// 3D transforms

to perceive a 3D effect on some of these function values
perspective is required

This is the transform function value to set the distance 
from the user to the z = 0 plane:
viewing it from a specific distance on the z-axis

perspective must be declared first (leftmost) 
when there are multiple transform function values

you can use the transform property to move and rotate objects in a 3D space 
(with the X, Y, and Z axes), then use perspective to control depth.


*/

.perspective {
    transform: perspective();

}


/*////////////////////////////////////////////////////////////////////////*/
/* the basics of perspective 
the z-axis becomes effective when perspective is used

body {
  font-family: 'Anton', sans-serif;
  background-color: #eee;
  color: #333;
  min-height: 100vh;
  display: -webkit-box;
  display: flex;
  -webkit-box-pack: center;
          justify-content: center;
  align-content: center;
  -webkit-box-align: center;
          align-items: center;
  flex-wrap: wrap;
}

#axesZ:checked ~ .container > .square {
  -webkit-animation: moveOnZ 2s infinite ease-in-out alternate;
          animation: moveOnZ 2s infinite ease-in-out alternate;
}

#axesZ:checked ~ .options > label.axesZ {
  background-color: greenyellow;
}

@-webkit-keyframes moveOnZ {
@keyframes moveOnZ {
  from {
    -webkit-transform: translateZ(-50px);
            transform: translateZ(-50px);
  }
  to {
    -webkit-transform: translateZ(50px);
            transform: translateZ(50px);
  }
}
label.usePerspective {
  display: block;
  text-align: center;
  padding: 0.5em 1em;
  border: 1px solid #777;
  border-radius: 4px;
  margin-top: 1.5em;
}

#usePerspective:checked ~ .container {
  -webkit-perspective: 240px;
          perspective: 240px;
}

#usePerspective:checked ~ .options label.usePerspective {
  background-color: greenyellow;
}

/////////////////////////////////////////////////////////////

#axesX:checked ~ .container > .square {
  -webkit-animation: rotateOnX 4s infinite linear;
          animation: rotateOnX 4s infinite linear;
}

#axesX:checked ~ .options > label.axesX {
  background-color: greenyellow;
}

@-webkit-keyframes rotateOnX {
  to {
    -webkit-transform: rotateX(360deg);
            transform: rotateX(360deg);
  }
}



moving: translate  (perspective in Z)
flipping: rotate (perspective in X Y)



The perspective-origin property determines the position from which 
you are “looking” at an object. If the origin is centered (which is the 
default) and the object is moved to the right, it will seem like you are 
looking at it from the left (and vice versa).

When the origin is set to the side, it’s like you are “looking” at the object 
from that side. The bigger the value, the further aside it will look.


//behaves according to the perspective rules assigned to the parent element.
.container {
  width: 200px;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  display: -webkit-box;
  display: flex;
  -webkit-box-align: center;
          align-items: center;
  -webkit-perspective: 240px;
          perspective: 240px;
}

//moving from side to side rotated side
.square {
  width: 100px;
  height: 100px;
  background-color: green;
  -webkit-transform: rotateY(90deg);
          transform: rotateY(90deg);
}

.containerA > .square {
  -webkit-animation: moveSquare 4s infinite ease-in-out alternate;
          animation: moveSquare 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveSquare {
  from {
    -webkit-transform: translateX(-100px) rotateY(90deg);
            transform: translateX(-100px) rotateY(90deg);
  }
  to {
    -webkit-transform: translateX(100px) rotateY(90deg);
            transform: translateX(100px) rotateY(90deg);
  }
}


//while having rotateY 90, can view from different angles using origin

.containerB {
  -webkit-animation: moveOrigin 4s infinite ease-in-out alternate;
          animation: moveOrigin 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveOrigin {
  from {
    -webkit-perspective-origin: left;
            perspective-origin: left;
  }
  to {
    -webkit-perspective-origin: right;
            perspective-origin: right;
  }
}






When rotating an object, its coordinate system is transformed along with the object.
When translating an object, it moves relative to its own coordinate system (rather than its parent’s coordinates).
The order in which these values are written can (and will) change the end result.


//rotation order explaination, if order changes, output is different
.squareA {
  -webkit-animation: sqrA 4s infinite ease-in-out;
          animation: sqrA 4s infinite ease-in-out;
}

@-webkit-keyframes sqrA {
  0%, 10% {
    -webkit-transform: none;
            transform: none;
  }
  50% {
    -webkit-transform: rotate(30deg);
            transform: rotate(30deg);
  }
  90%, 100% {
    -webkit-transform: rotate(30deg) translateX(140px);
            transform: rotate(30deg) translateX(140px);
  }
}






.container {
  position: relative;
  width: 100%;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  margin: 0.5em auto;
  -webkit-perspective: 420px;
          perspective: 420px;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
}

//  left: calc(50% - 50px);

//moving around itself
@-webkit-keyframes sqrA {
  from {
    -webkit-transform: translateX(120px) rotateY(0deg);
            transform: translateX(120px) rotateY(0deg);
  }
  to {
    -webkit-transform: translateX(120px) rotateY(360deg);
            transform: translateX(120px) rotateY(360deg);
  }
}

//moving around the axis, (can use that 180 degree on click to show new box ?)
@keyframes sqrB {
  from {
    -webkit-transform: rotateY(0deg) translateX(120px);
            transform: rotateY(0deg) translateX(120px);
  }
  to {
    -webkit-transform: rotateY(360deg) translateX(120px);
            transform: rotateY(360deg) translateX(120px);
  }
}



// we could simply change the values themselves to get the desired result 
instead of changing the order of the values.



//The transform-style property has two values: 

flat (default)
preserve-3d:
It tells the sides of the cube (the child elements) to be positioned 
in the same 3D space as the cube

“copies” the cube perspective to its children (the sides) and allows 
us to rotate just the cube, so we don’t need to animate each side separately.

It displays the child elements according to their position in the 3D space, 
regardless of their place in the DOM.

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////

The rotate3d() function rotates the element along the x, y, and z axes 
using the angle provided as an argument.
rotate3d(x, y, z, a)

transform: rotate3d(0);
transform: rotate3d(2, -1, -1, -0.2turn);
transform: rotate3d(0, 1, 0.5, 3.142rad);
transform: rotate3d(1, 1, 1, 45deg);

Is an <angle> representing the angle of the rotation. A positive angle 
denotes a clockwise rotation, a negative angle a counter-clockwise one.
deg, Degrees. There are 360 degrees in a full circle.
grad, Gradians, also known as "gons" or "grades" (although these aren't valid unit identifiers — you should still use grad as the unit identifier). There are 400 gradians in a full circle.
rad, Radians. There are 2Ï€ radians in a full circle.
turn, Turns. There is 1 turn in a full circle.


The default origin for the rotation is 50% 50%. You can use transform-origin 
to adjust the origin of the transformation:

  .rotated {
    transform-origin: 90% 90%;
    transform: rotate3d(1, -5, 1, -60deg);
  }





Note: scaleZ(sz) is equivalent to scale3d(1, 1, sz).

//translateZ and perspective work together
.moved {
  transform: perspective(500px) translate3d(10px, 0, 100px);
  background-color: pink;
}




The matrix() function is an alternative to the two-dimensional transform 
functions rotate(), skew(), scale(), and translate().
use the matrix() function instead of those functions.
matrix() for 2D transforms, matrix3d() for 3D transforms

transform: matrix(0.707107, 0.707107, -0.707107, 0.707107, 150, 0);

Any time you do a CSS transform, you're affecting the matrix. 
Even if you use another function such as rotate(), you're still affecting 
the matrix. The matrix determines the coordinates of the element — 
its position, size, orientation, etc.

matrix(a, b, c, d, e, f)
a, d
The arguments a and d represent how the element is scaled in the x and y direction respectively (just like in scale(a, d)).
b, c
The arguments b and c represent how the element is skewed (just like in skew(b, c)).
e, f
The arguments e and f represent how the element is translated in the x and y direction respectively (just like in translate(e, f)).

//Both lines have the same result
scale(2, 3);
matrix(2, 0, 0, 3, 0, 0);

https://css-tricks.com/how-css-perspective-works/
https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d

Fortunately, there are other options for getting the applicable arguments for the matrix() function:

One option is to create the transform using the various functions, then get the computed value from your browser's developer tools.
Another option is to use the Window.getComputedStyle() method to retrieve the computed value of the transform function.

//////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////
Rendering Performance
Users notice if sites and apps don't run well, so optimizing rendering performance is crucial!

Users of today’s web expect that the pages they visit will be interactive and 
smooth and that’s where you need to increasingly focus your time and effort. 
Pages should not only load quickly, but also run well; scrolling should be 
stick-to-finger fast, and animations and interactions should be silky smooth.

Most devices today refresh their screens 60 times a second. 
If there’s an animation or transition running, or the user is scrolling 
the pages, the browser needs to match the device’s refresh rate and put up 
1 new picture, or frame, for each of those screen refreshes.

It doesn’t have to be JavaScript that triggers a visual change, 
though: CSS Animations, Transitions, and the Web Animations API 
are also commonly used.


The key benefit of using transform is that it occurs during composition. 
This makes it cheaper to use compared to many other CSS properties.

You can see a table of what triggers are executed with each CSS property here.
https://web.archive.org/web/20220727225220/https://csstriggers.com/


A graphics processing unit (GPU) is a specialized electronic circuit designed 
to manipulate and alter memory to accelerate the creation of images in a frame 
buffer intended for output to a display device.

//////////////////////////////////////////////////////////////////////////







When we use a percentage value in translate, that percentage refers to the 
element's own size, not the available space within the parent container.
wether height or width

 .dialog-content {
    position: relative;
  }

  .close-btn {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-100%);
  }


With the magic of calc, we can even mix relative and absolute units:
transform: translateX(calc(1% + 0px));


The text scales up and down with the element
scaling the entire element

With transforms, we can skip a bunch of steps. This means that the 
calculations run quicker, leading to smoother motion.

Every element has an origin, the anchor that the transform functions execute from.
like an anchor point to angling

One common gotcha with transforms is that they don't work with inline 
elements in Flow layout.
The easiest fix is to switch it to use display: inline-block, 
or to use a different layout mode (eg. Flexbox or Grid).









//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
/* Transition




button {
  border: 1px solid black;
  border-radius: 5px;
  padding: 2% 5% 2% 5%;
  background-color: white;
  color: white;
  transition-property: background-color;
  transition-duration: 1s;
  transition-timing-function: ease-out;
  transition-delay: 0.25s;
}

button:hover {
  background-color: black;
  cursor: pointer;
}


transition duration: gradually happen over this period
transition timing function, ease-out, the color change will be faster at
the start than at the end of the transition


you can also trigger transitions by adding or removing classes with JavaScript. 
For example, clicking a button could append the “open” class to a dropdown menu, 
which would trigger the opening transition.


using a transform scenario forms a "stacking context"
when making many stacking contexts through various other means
when it comes to rendering our initial transform
we would repaint not only our div element
but also every element that is stacked on top of it in the stack context

if left, can cause transition to be slow

div {
  width: 100px;
  height: 100px;
  transition: transform 2s 1s; 
}

div:hover {
  transform: rotate(180deg);
}


second thing, keep your animations to only affect opacity and transform
if want to keep performance for animations on your web page
transition is an expensive operation
*/



.transitionButton {
    border: 1px solid black;
    border-radius: 5px;
    padding: 2% 5% 2% 5%;
    background-color: white;
    color: white;

    /*equivalent to   
    transition: background-color 1s ease-out 0.25s;     */
    transition-property: background-color;
    transition-duration: 1s;
    transition-timing-function: ease-out;
    transition-delay: 0.25s;
  }
  
  .transitionButton:hover {
    background-color: black;
    cursor: pointer;
  }


/*
//////////////////////////////////////////////////////////////////////////////

CSS transition provide a way to control animation speed when changing CSS properties

implicit transitions: between two states
explicit: defining delay, duration, timing


Each property's animation type determines how values combine - 
interpolate, add, or accumulate - for this property. 
Transitions only involve interpolation, 
whereas animations may use all three combination methods.

Animation types
. not animatable
. discrete: property's values are not additive, swaps from start value
to end value at 50%
. by computed value: corresponding inivicial components of the computed values
are combined using the indicated procedure for that value type
.Repeatable list: 

Using animations with auto may lead to unpredictable results, 
depending on the browser and its version, and should be avoided


////transition-property
Specifies the name or names of the CSS properties to which transitions should be applied.
changes to all other properties occur instantaneously as usual.

transition-property: margin-right, color; //this shortens the box
transition-property: all;

/* Keyword values
transition-property: none;
transition-property: all;

/* <custom-ident> values
transition-property: test_05;
transition-property: -specific;
transition-property: sliding-vertically;

/* Multiple values
transition-property: test1, animation4;
transition-property: all, height, color;
transition-property: all, -moz-specific, sliding;


.target {
  font-size: 14px;
  transition-property: font-size;
  transition-duration: 4s;
}

.target:hover {
  font-size: 36px;
}




////transition-duration
Specifies the duration over which transitions should occur. 
You can specify a single duration that applies to all properties during the 
transition, or multiple values to allow each property to transition over a 
different period of time.

If the number of specified durations is less than in the master list, 
the user agent repeats the list of durations. If the number of specified 
durations is more than in the master list, the list is truncated to the 
right size. In both the cases, the CSS declaration stays valid.

//both properties have different times
transition-duration: 3s, 1s;
transition-property: margin-right, color;

A time of 0s indicates that no transition will happen, default


////transition-timing-function
<easing-function> CSS data type denotes a mathematical function that describes 
the rate at which a numerical value changes.
This lets you vary the animation's speed over the course of its duration.
It may also be used to interpolate between two colors in a color gradient.
for transition and animation properties

*so can play with gradient by 
/* linear function and keyword
/* linear(<list-of-points>)
linear(1, -0.5, 0);
linear;

/* cubic-bezier function and keywords
/* cubic-bezier(<x1>, <y1>, <x2>, <y2>)
cubic-bezier(0.42, 0.0, 1.0, 1.0);
ease;
ease-in;
ease-out;
ease-in-out;

/* steps function and keywords
/* steps(<number-of-steps>, <direction>)
steps(4, end);
step-start;
step-end;

cubic-bezier
x1, y1, x2, y2
defining the cubic Bézier curve. x1 and x2 must be in the range [0, 1], 
otherwise the value is invalid.

ease
Indicates that the interpolation starts slowly, accelerates sharply, 
and then slows gradually towards the end. This keyword represents 
the easing function cubic-bezier(0.25, 0.1, 0.25, 1.0). It is similar 
to ease-in-out, though it accelerates more sharply at the beginning.

ease-in
Indicates that the interpolation starts slowly, then progressively speeds up 
until the end, at which point it stops abruptly. This keyword represents 
the easing function cubic-bezier(0.42, 0.0, 1.0, 1.0).

ease-in-out
Indicates that the interpolation starts slowly, speeds up, and then slows down 
towards the end. This keyword represents the easing function 
cubic-bezier(0.42, 0.0, 0.58, 1.0). At the beginning, it behaves like the 
ease-in function; at the end, it is like the ease-out function.

ease-out
Indicates that the interpolation starts abruptly and then progressively 
slows down towards the end. This keyword represents the easing function 
cubic-bezier(0.0, 0.0, 0.58, 1.0).


number-of-steps
A strictly positive <integer>, representing the amount of equidistant treads 
composing the stepping function.


direction
One of the following keywords that indicate when the jumps occur:

jump-start denotes that the first step or jump happens when the interpolation begins.
jump-end denotes that the last step or jump happens when the interpolation ends.
jump-both denotes that jumps occur at both the 0% and 100% marks, effectively adding a step during the interpolation iteration.
jump-none denotes no jump on either end. Instead, holding at both the 0% mark and the 100% mark, each for 1/n of the duration.
start is the equivalent of jump-start.
end is the equivalent of jump-end. This is the default.


step-start
Indicates that the interpolation jumps immediately to its final state, 
where it stays until the end. This keyword represents the easing 
function steps(1, jump-start) or steps(1, start).

step-end
Indicates that the interpolation stays in its initial state until the end, 
at which point it jumps directly to its final state. 
This keyword represents the easing function steps(1, jump-end) or steps(1, end).




//Linear easing function
linearly between its points, allowing you to approximate more complex animations 
like bounce and elastic effects
A typical use of the linear() function is to provide many points to create 
the illusion of a curve.

When you define the linear() function, you specify the linear easing points 
as a list, as in, linear(0, 0.25, 1). This linear() function produces an 
easing function that moves linearly from 0, to 0.25, then to 1.

Consider another example of the function: linear(0, 0.25 75%, 1). 
This produces a linear easing function that spends 75% of the time 
transitioning from 0 to .25 and the last 25% transitioning from .25 to 1.

The linear keyword produces a linear() function with two points. 
This is equivalent to the easing function cubic-bezier(0.0, 0.0, 1.0, 1.0).


//Cubic Bézier easing function
cubic-bezier subset of easing functions are often called "smooth" easing 
functions because they can be used to smooth down the start and end of 
the interpolation.
A cubic Bézier curve is defined by four points: P0, P1, P2, and P3.
P1/P2 0->1.0 can be more (jump)
certrain properties like color clip at 0->255 for above and below values
whole property ignored if invalid cubic-bezier is specified


//Step easing function
divides the domain of output values in equidistant steps.
sometimes also called staircase functions.
second parameter is optional

steps(2, jump-start)
steps(2, start)

steps(4, jump-end)
steps(4, end)

steps(5, jump-none)

steps(3, jump-both)

step-start and step-end;


////transition-delay
transition-delay: 1s, 250ms;transition-property: margin-right, color;



div {
  transition: <property> <duration> <timing-function> <delay>;
}

transition: width 2s, height 2s, background-color 2s, rotate 2s;




When property value lists are of different lengths
If any property's list of values is shorter than the others, its values are repeated to make them match. For example:

div {
  transition-property: opacity, left, top, height;
  transition-duration: 3s, 5s;
}
This is treated as if it were:

div {
  transition-property: opacity, left, top, height;
  transition-duration: 3s, 5s, 3s, 5s;
}
Similarly, if any property's value list is longer than that for transition-property, it's truncated, so if you have the following CSS:

div {
  transition-property: opacity, left;
  transition-duration: 3s, 5s, 2s, 1s;
}
This gets interpreted as:

div {
  transition-property: opacity, left;
  transition-duration: 3s, 5s;
}


Note: Care should be taken when using a transition immediately after:
adding the element to the DOM using .appendChild()
removing an element's display: none; property.
This is treated as if the initial state had never occurred and the element was 
always in its final state. The easy way to overcome this limitation is to apply 
a setTimeout() of a handful of milliseconds before changing the CSS property 
you intend to transition to.


////Detecting the start and completion of a transition
JS 

transitionend event

el.addEventListener("transitionend", propertyName, elapsedTime);
elapsedTime: A float indicating the number of seconds the transition had been 
running at the time the event fired. This value isn't affected by the value 
of transition-delay.

el.addEventListener("transitionend", updateTransition, true);
el.addEventListener("transitionrun", signalStart, true);    //before delay
el.addEventListener("transitionstart", signalStart, true); //after delay



//////////////////////////////////////////////////////////////////////////////
/*
The stacking context (z-index layers)
a three-dimensional conceptualization of HTML elements along an imaginary 
z-axis relative to the user

who is assumed to be facing the viewport or the webpage. HTML elements 
occupy this space in priority order based on element attributes.

the rendering order of certain elements is influenced by their z-index value. 
This occurs because these elements have special properties which cause them 
to form a stacking context.

A stacking context is formed, anywhere in the document, by any element in the following scenarios:

Root element of the document (<html>).
Element with a position value absolute or relative and z-index value other than auto.
Element with a position value fixed or sticky (sticky for all mobile browsers, but not older desktop browsers).
Element that is a child of a flex container, with z-index value other than auto.
Element that is a child of a grid container, with z-index value other than auto.
Element with an opacity value less than 1 (See the specification for opacity).
Element with a mix-blend-mode value other than normal.
Element with any of the following properties with value other than none:
transform
filter
backdrop-filter
perspective
clip-path
mask / mask-image / mask-border
Element with an isolation value isolate.
Element with a will-change value specifying any property that would create a stacking context on non-initial value (see this post).
Element with a contain value of layout, or paint, or a composite value that includes either of them (i.e. contain: strict, contain: content).
Within a stacking context, child elements are stacked according to the same rules explained just above. Importantly, the z-index values of its child stacking contexts only have meaning in this parent. Stacking contexts are treated atomically as a single unit in the parent stacking context.

In summary:

Stacking contexts can be contained in other stacking contexts, and together create a hierarchy of stacking contexts.
Each stacking context is completely independent of its siblings: only descendant elements are considered when stacking is processed.
Each stacking context is self-contained: after the element's contents are stacked, the whole element is considered in the stacking order of the parent stacking context.

When the z-index property is not specified on any element, elements are stacked in the following order (from bottom to top):
The background and borders of the root element.
Descendant non-positioned elements, in order of appearance in the HTML.
Floating elements.
Descendant positioned elements, in order of appearance in the HTML.

can use the ordering above to create layers without stacking index with z-axis

Root stacking context
DIV #2 (z-index: 2)
DIV #3 (z-index: 1)
DIV #4 (z-index: 10)

//////////////////////////////////////////////////////////////////////////////









//////////////////////////////////////////////////////////////////////////////

.animate {
  animation: opacity 2.5s both;
}

@keyframes opacity {
  0% {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

Before using any CSS property for animation (other than transform and opacity), 
determine the property's impact on the rendering pipeline. Avoid any property 
that triggers layout or paint unless absolutely necessary.

Style: Calculate the styles that apply to the elements.
Layout: Generate the geometry and position for each element.
Paint: Fill out the pixels for each element into layers.
Composite: Draw the layers to the screen.

When you animate something on a page that has already loaded these 
steps have to happen again. 
 If you change one element, the geometry of other elements may need to be recalculated.


these steps are sequential. For example, if you animate something that changes 
layout, the paint and composite steps also have to run again. Animating something 
that changes layout is therefore more expensive than animating something that 
only changes compositing.

//Animating composite properties #
Compositing is the process of separating the page into layers, converting the information about how the page should look into pixels (rasterization), and putting the layers together to create a page (compositing).


Chromium-based browsers and WebKit create a new layer for any element which 
has a CSS transition or animation on opacity.

//What is a layer
By placing the things that will be animated or transitioned onto a new layer, 
the browser only needs to repaint those items and not everything else.

creating new layers should be done with care because each layer uses memory.
herefore you may well hit constraints of bandwidth between the CPU and GPU.

css based animations can keep going without being interrupted.
because they are on the compositor thread
different from the browser's main thread where styling, painting, js are executed

other changes to transforms and opacity can, in many cases, also be 
handled by the compositor thread.

use transform translateX better than left/right
Because the browser sees that none of the properties would cause a reflow or 
repaint, it can apply a compositing optimization: painting two images as 
compositing layers and sending them to the GPU.

In this case, for every animation frame, the browser has to recalculate 
the element’s geometry (i.e. reflow), render the image of the page’s new state 
(i.e. repaint) and then send it again to the GPU to display on screen. We know 
that repainting is very performance-costly, but every modern browser 
is smart enough to repaint only the changed area of the page, instead of 
the entire page. While browsers can repaint very fast in most cases, our 
animation is still not smooth.


It would be much more effective just to paint two separate images — one for 
the A element and one for the entire page without the A element — 
and then simply offset those images relative to each other. In other words, 
composing the images of cached elements would be faster. And this is exactly 
where the GPU shines

To optimize the compositing, the browser has to ensure that the animated CSS property:

does not affect the document’s flow,
does not depend on the document’s flow,
does not cause a repaint.

One might think that the top and left properties, along with the positions 
absolute and fixed, don’t depend on an element’s environment, but that’s not so. 
For example, a left property may receive a percentage value that depends on the 
size of .offsetParent; also, em, vh and other units depend on their environment. 
Rather, transform and opacity are the only CSS properties that meet the conditions 
above.

What does a GPU payload look like? In most cases, it consists of layer images, along with additional instructions such as for the layer’s size, offset, animation parameters, etc. Here is roughly what making a payload and transferring data with the GPU looks like:

Paint each compositing layer to a separate image.
Prepare the layer data (size, offset, opacity, etc.).
Prepare shaders for the animation (if applicable).
Send the data to the GPU.


You guess it! It will forcibly create a new compositing layer for element A — 
and add another heavy repaint, of course:

We stumble upon implicit composing much more often than you might think. 
A browser will promote an element to a compositing layer for many reasons, 
just a few of which are:

3D transforms: translate3d, translateZ and so on;
<video>, <canvas> and <iframe> elements;
animation of transform and opacity via Element.animate();
animation of transform and opacity via СSS transitions and animations;
position: fixed;
will-change;
filter;


//Memory Consumption #
Another gentle reminder that the GPU is a separate computer: 
It’s required not just to send rendered layer images to the GPU, 
but to store them as well for later reuse in animation.

using many animated controls, parallax effects, high-resolution images and other visual enhancements,
and you’ll end up with a page filling all available memory on the device.
This might not be an issue for desktop clients, but it really hurts mobile users. 

A properly crafted animation works in a separate thread and is not blocked by heavy JavaScript calculations.

Every composite layer consumes additional memory. 
Memory is a precious resource on mobile devices. 
Excessive memory use could crash the browser.

If you don’t consider implicit compositing, 
then the chances of slow repainting, extra memory usage 
and browser crashes are very high.

>layer divide reason tools in browsers

AVOID IMPLICIT COMPOSITING #
this might cause the animation to start very slowly.
“Timeline” panel, you’ll see that the animation’s start and end are accompanied with repaints of large areas:


Here’s what browser did, step by step:

Right after the page loads, the browser doesn’t find any reason for compositing, 
so it picks the optimal strategy: painting the page’s entire contents on a 
single background layer.
By clicking the “Play” button, we’re explicitly adding compositing to element A 
— a transition with the transform property. But the browser determines that 
element A is below element B in the stacking order, so it promotes B to its 
own compositing layer, too (implicit compositing).
Promotion to a compositing layer always causes a repaint: The browser has to 
create a new texture for the element and remove it from the previous layer.
Right after the animation finishes, we remove the reason for compositing from 
A element. Once again, the browser sees that it doesn’t need to waste resources 
on compositing, so it falls back to the optimal strategy: keeping the page’s 
entire contents on a single layer, which means it has to paint A and B back on 
the background layer (another repaint) and send the updated texture to the GPU. 
As in the step above, this could cause flickering.




To get rid of implicit compositing issues and to reduce visual artifacts, 
I recommend the following:

Try to keep animated objects as high as possible in the z-index. Ideally, 
these elements should be direct children of the body element. Of course, 
this is not always possible in the markup when an animated element is nested 
deep inside the DOM tree and depends on the normal flow. In such cases, 
you could clone the element and put it in the body for animation only.

You can give browser a hint that you’re going to use compositing with the 
will-change CSS property. With this property set on an element, 
the browser will (but not always!) promote it to a compositing layer 
in advance, so that the animation can start and stop smoothly. But don’t 
misuse this property, or else you’ll end up with a tremendous increase in 
memory consumption!


//ANIMATE transform AND opacity PROPERTIES ONLY #

#bg-change {
 width: 100px;
 height: 100px;
 background: red;
 transition: background 0.4s;
}

#bg-change:hover {
 background: blue;
}

//can be changed to
//Instead of animating the background-color property, we would add a 
//layer on top and animate its opacity:


<div id="bg-change"></div>
<style>
#bg-change {
 width: 100px;
 height: 100px;
 background: red;
}

#bg-change::before {
 background: blue;
 opacity: 0;
 transition: opacity 0.4s;
}

#bg-change:hover::before {
 opacity: 1;
}


//This animation would be much faster and smoother, 
but keep in mind that it could cause implicit compositing and require 
additional memory. Yet memory consumption can be reduced greatly in this case.



The difference is that the physical size of #a is 100 × 100 pixels 
(100 × 100 × 4 = 40,000 bytes), whereas #b is only 10 × 10 pixels 
(10 × 10 × 4 = 400 bytes) but upscaled to 100 × 100 pixels with 
transform: scale(10). Because #b is a composite layer, due to the 
will-change property, the transform now occurs entirely on the GPU 
during the final image paint.
//this trick reduces memory consumption significantly for very simple, 
solid-colored layers only. But, for example, if you want to animate a 
large photo, you could downsize it by 5 to 10% and then upscale it; 
users might not see any difference, and you would save a few megabytes 
of precious memory.

<style>
#a, #b {
 will-change: transform;
}

#a {    //39kb
 width: 100px;
 height: 100px;
}

#b {    //400b
 width: 10px;
 height: 10px;
 transform: scale(10);
}
</style>


We already know that animation of transform and opacity via CSS transitions 
or animations automatically creates a compositing layer and works on the GPU. 
We could also animate via JavaScript, but we’d have to add transform: translateZ(0) 
or will-change: transform, opacity first in order to ensure that the element 
gets its own compositing layer.

JavaScript animation happens when each step is manually calculated in a 
requestAnimationFrame callback. Animation via Element.animate() is a 
variation of declarative CSS animation.

On the one hand, creating a simple and reusable animation via a CSS 
transition or animation is very easy; on the other, creating complex 
animation with fancy trajectories is much easier with JavaScript animation 
than with CSS. Also, JavaScript is the only way to interact with user input.

CSS-based animation has a very important feature: It works entirely on the GPU. 
Because you declare how an animation should start and finish,

in case of imperative Javascript
, we’d have to calculate the new frame in the main browser 
thread and send it to the GPU at least 60 times per second. 
and the main thread gets blocked by intensive JavaScript calculations. 


//example
using an image to be rotated 360
can be achieved 
using multiple rays/sunrays rotating

@always think of faster ways that can get the same result
with less expensive memory calculations

//JS//
const container = document.querySelector('.sun');
const raysAmount = 12;
const angularVelocity = 0.5;
const rays = createRays(container, raysAmount);

animate();

function animate() {
    rays.forEach(ray => {
        ray.angle += angularVelocity;
        ray.elem.style.transform = `rotate(${ray.angle % 360}deg)`;
    });
    requestAnimationFrame(animate);
}

function createRays(container, amount) {
    const rays = [];
    const rotationStep = 360 / amount;
    while (amount--) {
        const angle = rotationStep * amount;
        const elem = document.createElement('div');
        elem.className = 'sun-ray';
        container.appendChild(elem);
        rays.push({elem, angle});
    }
    return rays;
}
//same example with scale that reduces GPU consumption
const container = document.querySelector('.sun');
const raysAmount = 12;
const angularVelocity = 0.5;
const downscale = 0.1;
const rays = createRays(container, raysAmount, downscale);


animate();

function animate() {
    rays.forEach(ray => {
        ray.angle += angularVelocity;
        ray.elem.style.transform = `rotate(${ray.angle % 360}deg) scale(${ray.scale})`;
    });
    requestAnimationFrame(animate);
}

function createRays(container, amount, downscale) {
    const rays = [];
    const rotationStep = 360 / amount;
    while (amount--) {
        const angle = rotationStep * amount;
        const elem = document.createElement('div');
        elem.className = 'sun-ray';
        container.appendChild(elem);

        let scale = 1;
        if (downscale) {
            const origWidth = elem.offsetWidth, origHeight = elem.offsetHeight;
            const width = origWidth * (1 - downscale);
            const height = origHeight * (1 - downscale);
            elem.style.width = width + 'px';
            elem.style.height = height + 'px';
            scale = origWidth / width;
        }

        rays.push({elem, angle, scale});
    }
    return rays;
}

The new animation looks the same as the previous one but is twice as small 
in memory consumption.

the rays don’t have any crisp contrasting elements. 
This means we can send a lower-resolution ray texture to the GPU and upscale 
it afterwards, which allows us to reduce memory consumption a bit.

next you can import this js functionality in css code

Always negotiate with the client and designer about all animations and effects on the website. It could affect the page’s markup greatly and make for better compositing.
Watch out for the number and size of composite layers from the very beginning — especially ones created by implicit compositing. The “Layers” panel in your browser’s development tools is your best friend.
Modern browsers make heavy use of compositing not just for animation but to optimize the painting of page elements. For example, position: fixed and the iframe and video elements use compositing.
The size of compositing layers is likely be more important than the number of layers. 

if optimization has negative impact
To bypass this optimization, I add a small, unique translateZ() 
value to each element, such as translateZ(0.0001px), translateZ(0.0002px), etc.
The browser will determine that the elements lie on different planes in the 3D 
space and, thus, skip optimization.

You can’t just add transform: translateZ(0) or will-change: transform 
to any random element to virtually improve animation performance or 
to get rid of visual artifacts. GPU compositing has many drawbacks and 
tradeoffs to be considered. When not used sparingly, compositing will 
decrease overall performance at best, and crash browsers at worst.


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

As explained in Why are some animations slow?, by placing elements on a new 
layer they can be repainted without also requiring the rest of the layout to 
be repainted.

Browsers will often make good decisions about which items should be placed on a 
new layer, but you can manually force layer creation with the will-change property. 
As the name suggests, this property tells the browser that this element is going 
to be changed in some way.

As layer creation can cause other performance issues, this property should not 
be used as a premature optimization. Instead, you should only use it when you 
are seeing jank and think that promoting the element to a new layer may help.

body > .sidebar {
  will-change: transform;
}

ome items on your page may not frequently change, and so it would be better to 
apply will-change using JavaScript at a point where it becomes likely the change 
will occur. You'll need to make sure to give the browser enough time to perform 
the optimizations needed and then remove the property once the changing has stopped.

If you need a way to force layer creation in one of the rare browsers that doesn't 
support will-change (most likely Internet Explorer at this point), 
you can set transform: translateZ(0).


//Debug slow or janky animations #
Chrome DevTools and Firefox DevTools have lots of tools to help you 
figure out why your animations are slow or janky.

Chrome:
Open the Performance panel.
Record runtime performance while your animation is happening.
Inspect the Summary tab.

Firefox:
Open the Performance panel.
In the panel Start Recording Performance while your animation is happening.
Stop the recording and inspect the Waterfall tab.


Alternatively, you can open the Rendering tab in the following ways to check FPS drop
Press Esc to open the Drawer, and, in the top left corner, click More Tools More > Rendering.
In the top right corner, click More Options More > More Tools > Rendering.


//Check if an animation triggers paint #
When it comes to painting, some things are more expensive than others. 
For example, anything that involves a blur (like a shadow, for example) 
is going to take longer to paint than drawing a red box. In terms of CSS, 
however, this isn't always obvious: 
background: red; and box-shadow: 0, 4px, 4px, rgba(0,0,0,0.5); 
don't necessarily look like they have vastly different performance 
characteristics, but they do.

Browser DevTools can help you to identify which areas need to be repainted, 
and performance issues related to painting.

Chrome DevTools #
Open the Rendering tab of Chrome DevTools.
Select Paint Flashing.
Move the pointer around the screen.

If you see the whole screen flashing, or areas that you don't think should 
change highlighted then you can do some investigation.



select frame inspection


Conclusion #
Where possible restrict animations to opacity and transform in order to 
keep animations on the compositing stage of the rendering path. Use DevTools 
to check which stage of the path is being affected by your animations.

Use the paint profiler to see if any paint operations are particularly 
expensive. If you find anything, see if a different CSS property will give 
the same look and feel with better performance.

Use the will-change property sparingly, and only if you encounter a 
performance issue.






//////////////////////////////////////////////////////////////////////////////
/*

check the impacts on the page rendering steps on animating 
css properties 
https://web.archive.org/web/20220727225220/https://csstriggers.com/


a solution to a heavy repaint problem even with using transform/opacity
is to alter the stacking context (z-index) to create separate layers
either remove the position: relative from the li items, or add 
position: relative and a z-index to the span element.
it wasn’t the CSS transition itself that was causing the issue, but the 
elements and their stacking order.

@checkout 3D View panel in Edge DevTools



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
/*
Keyframes
animations greatly expand on some capabilities that transitions simply do not have
Animations do no need trigger like :hover/:focus

add more flexibility than the transition-timing-function in transitions
both animations and transitions have their use


#ball {
  width: 100px;
  height: 100px;
  background-color: red;
  border: 1px solid black;
  border-radius: 50%;
  animation-duration: 2s;
  animation-name: change-color;
  animation-iteration-count: infinite;
  animation-direction: alternate; //alternate direction on the completion of one cycle, or reset to the start point 

}

@keyframes change-color {
  from {
    background-color: red;
  }

50% {
width: 200px;
height: 200px;
background-color: blue;
}

  to {
    background-color: green;
  }
}


You can read from/0% as meaning ‘at zero seconds’ and to/100% as ‘at 2 seconds’ 
according to our animation-duration


//////////////////////////////////////////////////////////////////////////////

The animations run well, even under moderate system load. Simple animations can 
often perform poorly in JavaScript. The rendering engine can use frame-skipping 
and other techniques to keep the performance as smooth as possible.

Letting the browser control the animation sequence lets the browser optimize 
performance and efficiency by, for example, reducing the update frequency of 
animations running in tabs that aren't currently visible.



//animation-delay: 250ms;



//animation-direction: normal/reverse/alternate/alternate-reverse;
on reverse
Animation steps are performed backwards, and timing functions are also reversed. 
For example, an ease-in timing function becomes ease-out.

alternate
The animation "reverses" direction each cycle, with the first iteration being 
played forwards. The count to determine if a cycle is even or odd starts at one.

alternate-reverse
The animation reverses direction each cycle, with the first iteration being 
played backwards.



//animation-duration 
CSS property sets the length of time that an animation takes to complete one cycle.

If no value is provided, the default value of 0s is used, in which case the 
animation still executes (the animationStart and animationEnd events are fired). 
Whether or not the animation will be visible when the duration is 0s will depend 
on the value of animation-fill-mode

If animation-fill-mode is set to forwards or both, the last frame of the 
animation will be displayed, as defined by animation-direction, after the 
animation-delay expires. and the opposite on backwards or both, none=none

negative values are invalid


//animation-fill-mode
none/forwards/backwards/both

none
The animation will not apply any styles to the target when it's not executing. 
The element will instead be displayed using any other CSS rules applied to it. 
This is the default value.

forwards
The target will retain the computed values set by the last keyframe 
encountered during execution.
animation-direction	    animation-iteration-count	last keyframe encountered
normal	                even or odd	                100% or to
reverse	                even or odd	                0% or from
alternate	            even	                    0% or from
alternate	            odd	                        100% or to
alternate-reverse	    even	                    100% or to
alternate-reverse	    odd	                        0% or from

backwards
The animation will apply the values defined in the first relevant keyframe as soon as it is applied to the target, and retain this during the animation-delay period. The first relevant keyframe depends on the value of animation-direction:

animation-direction	first relevant keyframe
normal or alternate	0% or from
reverse or alternate-reverse	100% or to


both
The animation will follow the rules for both forwards and backwards, 
thus extending the animation properties in both directions.



//animation-iteration-count
animation-iteration-count: 1.5;//plays one and half a cycle
negative values are invalid, 1 is default, 0.5 half animation


//animation-name 
specifies the names of one or more @keyframes 

none
A special keyword denoting no keyframes. It can be used to deactivate an animation 
without changing the ordering of the other identifiers, or to deactivate animations 
coming from the cascade.

name
two dashes are forbidden at the beginning of the identifier. Furthermore, 
the identifier can't be none, unset, initial, or inherit.

//animation-play-state
sets whether an animation is running or paused (paused at the place it is)
Resuming a paused animation will start the animation from where it left off at the time it was paused,

can be used to trigger running(play) on hover for example


//animation-timing-function
ease, ease-in, ease-out, ease-in-out, linear, step-start, step-end
animation-timing-function: cubic-bezier(0.1, 0.7, 1, 0.1);
animation-timing-function: steps(4, end);
/* Steps Function keywords
animation-timing-function: steps(4, jump-start);
animation-timing-function: steps(10, jump-end);
animation-timing-function: steps(20, jump-none);
animation-timing-function: steps(5, jump-both);
animation-timing-function: steps(6, start);
animation-timing-function: steps(8, end);


steps(n, <jumpterm>)
Displays an animation iteration along n stops along the transition, 
displaying each stop for equal lengths of time. For example, if n is 5, 
there are 5 steps. Whether the animation holds temporarily at 0%, 20%, 40%, 60% 
and 80%, on the 20%, 40%, 60%, 80% and 100%, or makes 5 stops between the 0% 
and 100% along the animation, or makes 5 stops including the 0% and 100% marks 
(on the 0%, 25%, 50%, 75%, and 100%) depends on which of the following jump 
terms is used:

jump-start
Denotes a left-continuous function, so that the first jump happens when the animation begins;

jump-end
Denotes a right-continuous function, so that the last jump happens when the animation ends;

jump-none
There is no jump on either end. Instead, holding at both the 0% mark and the 100% mark, each for 1/n of the duration.

jump-both
Includes pauses at both the 0% and 100% marks, effectively adding a step during the animation iteration.

start
Same as jump-start.

end
Same as jump-end.

step-start
Equal to steps(1, jump-start)

step-end
Equal to steps(1, jump-end)


////////////////////////////////////////////////////////////////////////

If from/0% or to/100% is not specified, the browser starts or finishes 
the animation using the computed values of all attributes.


animation: duration | easing-function | delay | iteration-count | 
direction | fill-mode | play-state | name;


When the animation-duration value is omitted from the animation shorthand property, 
the value for this property defaults to 0s. In this case, the animation will still 
occur (the animationStart and animationEnd events will be fired) but no animation 
will be visible.

multiple combined animation property

animation:  4s linear 0s infinite alternate rise, 
            24s linear 0s infinite psychedelic;

the last animation properties will overwrite the one before it, if same property

//ex: slide in animation
p {
  animation-duration: 3s;
  animation-name: slidein;
}

@keyframes slidein {
  from {
    margin-left: 100%;
    width: 300%;
  }

  //  75% { //ths will increase the font and revert back to original
    font-size: 300%;
    margin-left: 25%;
    width: 150%;
  }

  to {
    margin-left: 0%;
    width: 100%;
  }
}


Note that animations like this can cause the page to become wider than the 
browser window. To avoid this problem put the element to be animated in a 
container, and set overflow:hidden on the container.


You can get additional control over animations — as well as useful information 
about them — by making use of animation events. These events, represented by 
the AnimationEvent object, can be used to detect when animations start, finish, 
and begin a new iteration. Each event includes the time at which it occurred 
as well as the name of the animation that triggered the event.


const element = document.getElementById("watchme");
element.addEventListener("animationstart", listener, false);
element.addEventListener("animationend", listener, false);
element.addEventListener("animationiteration", listener, false);

element.className = "slidein";


Because the animationstart event fires as soon as the animation starts, 
and in our case, that happens before our code runs. So we'll start the animation 
ourselves by setting the class of the element to the style that gets animated 
after the fact.


function listener(event) {
  const l = document.createElement("li");
  switch (event.type) {
    case "animationstart":
      l.textContent = `Started: elapsed time is ${event.elapsedTime}`;
      break;
    case "animationend":
      l.textContent = `Ended: elapsed time is ${event.elapsedTime}`;
      break;
    case "animationiteration":
      l.textContent = `New loop started at time ${event.elapsedTime}`;
      break;
  }
  document.getElementById("output").appendChild(l);
}


If a keyframe rule doesn't specify the start or end states of the animation (that is, 0%/from and 100%/to), 
browsers will use the element's existing styles for the start/end states. 
This can be used to animate an element from its initial state and back.
Properties that can't be animated in keyframe rules are ignored, but supported 
properties will still be animated.

If multiple keyframe sets exist for a given name, the last one encountered by 
the parser is used. @keyframes rules don't cascade, so animations never derive 
keyframes from more than one rule set.

If a given animation time offset is duplicated, all keyframes in the @keyframes 
rule for that percentage are used for that frame. There is cascading within a 
@keyframes rule if multiple keyframes specify the same percentage values.

Declarations in a keyframe qualified with !important are ignored.


////////////////////////////////////////////////////////////////////////



/* Multiple animations
animation-name: test1, animation4;
animation-direction: normal, reverse;
animation-delay: 2.1s, 480ms; //seconds or ms
animation-duration: 1.64s, 15.22s;
animation-fill-mode: none, backwards;
animation-iteration-count: 2, infinite;
animation-play-state: paused, running, running;
animation-timing-function: ease, step-start, cubic-bezier(0.1, 0.7, 1, 0.1);


*/