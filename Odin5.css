
/*
////2D Transforms

Almost all elements can have the transform property applied to it, 
with the exceptions being <col>, <colgroup>, and non-replaced inline elements. 

“Non-replaced” simply refers to elements whose content is contained within the HTML 
document (<span>, <b>, and <em>, for example), 

as opposed to a “replaced” element’s content being contained outside of the document 
(<a>, <iframe>, and <img>, for example).


rotate, scale, skew, translate




*/

.margin {
    margin: 0 0 100px 100px;
}

.box {
    background: black;
    height: 100px;
    width: 100px;
}

.skewXY {
    /* X and Y values respectively, if one then its X 
    also skewX, skewY separately */
    transform: skew(45deg, -0.5rad);

}


.mainContainer {
    height: 200px;
    width: 200px;
    border: 1px solid black;

    display: flex;
    align-items: center;
    justify-content: center;

    margin: 0 0 100px 100px;

}

.TranslateXY {
    transform: translate(20px, -33%);
}


/* order of chain will affect the display, 
as these two chains have the same values but different order 
composite transforms are effectively applied in order from right to left.

When an element is rotated before being translated, 
the translate direction is on the rotated axis.

transformation are always in the position defined by transform-origin 
(by default the center of the element)

the other difference with the left to right version is 
that you use a fixed system of coordinates/angles.

consider making use of the prefers-reduced-motion media feature — 
use it to write a media query that will turn off animations if the user 
has reduced animation specified in their system preferences.

*/

.TranslateChain1 {
    transform: skew(45deg, -0.5rad) translate(20px, 33%);
}


.TranslateChain2 {
    transform: translate(20px, 33%) skew(45deg, -0.5rad) ;
}




/* transformation example of ltr and rtl
The left element is using a left to right progression and the right one a right 
to left progression. Note how the corners of the left one are following 
an elliptical path and how the shape is not preserved during the rotation.
*/
.object
{
  width: 100px; height: 100px;
  background: rgb(114,34,34);
  animation: ltr 5s infinite;
}
.object2 {
    animation-name: rtl;
}

@keyframes ltr
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(.5) rotate( 0deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}
@keyframes rtl
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(1 ) rotate(45deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}



/*
//// 3D transforms

to perceive a 3D effect on some of these function values
perspective is required

This is the transform function value to set the distance 
from the user to the z = 0 plane:
viewing it from a specific distance on the z-axis

perspective must be declared first (leftmost) 
when there are multiple transform function values

you can use the transform property to move and rotate objects in a 3D space 
(with the X, Y, and Z axes), then use perspective to control depth.


*/

.perspective {
    transform: perspective();

}


/*////////////////////////////////////////////////////////////////////////*/
/* the basics of perspective 
the z-axis becomes effective when perspective is used

body {
  font-family: 'Anton', sans-serif;
  background-color: #eee;
  color: #333;
  min-height: 100vh;
  display: -webkit-box;
  display: flex;
  -webkit-box-pack: center;
          justify-content: center;
  align-content: center;
  -webkit-box-align: center;
          align-items: center;
  flex-wrap: wrap;
}

#axesZ:checked ~ .container > .square {
  -webkit-animation: moveOnZ 2s infinite ease-in-out alternate;
          animation: moveOnZ 2s infinite ease-in-out alternate;
}

#axesZ:checked ~ .options > label.axesZ {
  background-color: greenyellow;
}

@-webkit-keyframes moveOnZ {
@keyframes moveOnZ {
  from {
    -webkit-transform: translateZ(-50px);
            transform: translateZ(-50px);
  }
  to {
    -webkit-transform: translateZ(50px);
            transform: translateZ(50px);
  }
}
label.usePerspective {
  display: block;
  text-align: center;
  padding: 0.5em 1em;
  border: 1px solid #777;
  border-radius: 4px;
  margin-top: 1.5em;
}

#usePerspective:checked ~ .container {
  -webkit-perspective: 240px;
          perspective: 240px;
}

#usePerspective:checked ~ .options label.usePerspective {
  background-color: greenyellow;
}

/////////////////////////////////////////////////////////////

#axesX:checked ~ .container > .square {
  -webkit-animation: rotateOnX 4s infinite linear;
          animation: rotateOnX 4s infinite linear;
}

#axesX:checked ~ .options > label.axesX {
  background-color: greenyellow;
}

@-webkit-keyframes rotateOnX {
  to {
    -webkit-transform: rotateX(360deg);
            transform: rotateX(360deg);
  }
}



moving: translate  (perspective in Z)
flipping: rotate (perspective in X Y)



The perspective-origin property determines the position from which 
you are “looking” at an object. If the origin is centered (which is the 
default) and the object is moved to the right, it will seem like you are 
looking at it from the left (and vice versa).

When the origin is set to the side, it’s like you are “looking” at the object 
from that side. The bigger the value, the further aside it will look.


//behaves according to the perspective rules assigned to the parent element.
.container {
  width: 200px;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  display: -webkit-box;
  display: flex;
  -webkit-box-align: center;
          align-items: center;
  -webkit-perspective: 240px;
          perspective: 240px;
}

//moving from side to side rotated side
.square {
  width: 100px;
  height: 100px;
  background-color: green;
  -webkit-transform: rotateY(90deg);
          transform: rotateY(90deg);
}

.containerA > .square {
  -webkit-animation: moveSquare 4s infinite ease-in-out alternate;
          animation: moveSquare 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveSquare {
  from {
    -webkit-transform: translateX(-100px) rotateY(90deg);
            transform: translateX(-100px) rotateY(90deg);
  }
  to {
    -webkit-transform: translateX(100px) rotateY(90deg);
            transform: translateX(100px) rotateY(90deg);
  }
}


//while having rotateY 90, can view from different angles using origin

.containerB {
  -webkit-animation: moveOrigin 4s infinite ease-in-out alternate;
          animation: moveOrigin 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveOrigin {
  from {
    -webkit-perspective-origin: left;
            perspective-origin: left;
  }
  to {
    -webkit-perspective-origin: right;
            perspective-origin: right;
  }
}






When rotating an object, its coordinate system is transformed along with the object.
When translating an object, it moves relative to its own coordinate system (rather than its parent’s coordinates).
The order in which these values are written can (and will) change the end result.


//rotation order explaination, if order changes, output is different
.squareA {
  -webkit-animation: sqrA 4s infinite ease-in-out;
          animation: sqrA 4s infinite ease-in-out;
}

@-webkit-keyframes sqrA {
  0%, 10% {
    -webkit-transform: none;
            transform: none;
  }
  50% {
    -webkit-transform: rotate(30deg);
            transform: rotate(30deg);
  }
  90%, 100% {
    -webkit-transform: rotate(30deg) translateX(140px);
            transform: rotate(30deg) translateX(140px);
  }
}






.container {
  position: relative;
  width: 100%;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  margin: 0.5em auto;
  -webkit-perspective: 420px;
          perspective: 420px;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
}

//  left: calc(50% - 50px);

//moving around itself
@-webkit-keyframes sqrA {
  from {
    -webkit-transform: translateX(120px) rotateY(0deg);
            transform: translateX(120px) rotateY(0deg);
  }
  to {
    -webkit-transform: translateX(120px) rotateY(360deg);
            transform: translateX(120px) rotateY(360deg);
  }
}

//moving around the axis, (can use that 180 degree on click to show new box ?)
@keyframes sqrB {
  from {
    -webkit-transform: rotateY(0deg) translateX(120px);
            transform: rotateY(0deg) translateX(120px);
  }
  to {
    -webkit-transform: rotateY(360deg) translateX(120px);
            transform: rotateY(360deg) translateX(120px);
  }
}



// we could simply change the values themselves to get the desired result 
instead of changing the order of the values.



//The transform-style property has two values: 

flat (default)
preserve-3d:
It tells the sides of the cube (the child elements) to be positioned 
in the same 3D space as the cube

“copies” the cube perspective to its children (the sides) and allows 
us to rotate just the cube, so we don’t need to animate each side separately.

It displays the child elements according to their position in the 3D space, 
regardless of their place in the DOM.

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////

The rotate3d() function rotates the element along the x, y, and z axes 
using the angle provided as an argument.
rotate3d(x, y, z, a)

transform: rotate3d(0);
transform: rotate3d(2, -1, -1, -0.2turn);
transform: rotate3d(0, 1, 0.5, 3.142rad);
transform: rotate3d(1, 1, 1, 45deg);

Is an <angle> representing the angle of the rotation. A positive angle 
denotes a clockwise rotation, a negative angle a counter-clockwise one.
deg, Degrees. There are 360 degrees in a full circle.
grad, Gradians, also known as "gons" or "grades" (although these aren't valid unit identifiers — you should still use grad as the unit identifier). There are 400 gradians in a full circle.
rad, Radians. There are 2Ï€ radians in a full circle.
turn, Turns. There is 1 turn in a full circle.


The default origin for the rotation is 50% 50%. You can use transform-origin 
to adjust the origin of the transformation:

  .rotated {
    transform-origin: 90% 90%;
    transform: rotate3d(1, -5, 1, -60deg);
  }





Note: scaleZ(sz) is equivalent to scale3d(1, 1, sz).

//translateZ and perspective work together
.moved {
  transform: perspective(500px) translate3d(10px, 0, 100px);
  background-color: pink;
}




The matrix() function is an alternative to the two-dimensional transform 
functions rotate(), skew(), scale(), and translate().
use the matrix() function instead of those functions.
matrix() for 2D transforms, matrix3d() for 3D transforms

transform: matrix(0.707107, 0.707107, -0.707107, 0.707107, 150, 0);

Any time you do a CSS transform, you're affecting the matrix. 
Even if you use another function such as rotate(), you're still affecting 
the matrix. The matrix determines the coordinates of the element — 
its position, size, orientation, etc.

matrix(a, b, c, d, e, f)
a, d
The arguments a and d represent how the element is scaled in the x and y direction respectively (just like in scale(a, d)).
b, c
The arguments b and c represent how the element is skewed (just like in skew(b, c)).
e, f
The arguments e and f represent how the element is translated in the x and y direction respectively (just like in translate(e, f)).

//Both lines have the same result
scale(2, 3);
matrix(2, 0, 0, 3, 0, 0);

https://css-tricks.com/how-css-perspective-works/
https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d

Fortunately, there are other options for getting the applicable arguments for the matrix() function:

One option is to create the transform using the various functions, then get the computed value from your browser's developer tools.
Another option is to use the Window.getComputedStyle() method to retrieve the computed value of the transform function.

//////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////
Rendering Performance
Users notice if sites and apps don't run well, so optimizing rendering performance is crucial!

Users of today’s web expect that the pages they visit will be interactive and 
smooth and that’s where you need to increasingly focus your time and effort. 
Pages should not only load quickly, but also run well; scrolling should be 
stick-to-finger fast, and animations and interactions should be silky smooth.

Most devices today refresh their screens 60 times a second. 
If there’s an animation or transition running, or the user is scrolling 
the pages, the browser needs to match the device’s refresh rate and put up 
1 new picture, or frame, for each of those screen refreshes.

It doesn’t have to be JavaScript that triggers a visual change, 
though: CSS Animations, Transitions, and the Web Animations API 
are also commonly used.


The key benefit of using transform is that it occurs during composition. 
This makes it cheaper to use compared to many other CSS properties.

You can see a table of what triggers are executed with each CSS property here.
https://web.archive.org/web/20220727225220/https://csstriggers.com/


A graphics processing unit (GPU) is a specialized electronic circuit designed 
to manipulate and alter memory to accelerate the creation of images in a frame 
buffer intended for output to a display device.

//////////////////////////////////////////////////////////////////////////







When we use a percentage value in translate, that percentage refers to the 
element's own size, not the available space within the parent container.
wether height or width

 .dialog-content {
    position: relative;
  }

  .close-btn {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-100%);
  }


With the magic of calc, we can even mix relative and absolute units:
transform: translateX(calc(1% + 0px));


The text scales up and down with the element
scaling the entire element

With transforms, we can skip a bunch of steps. This means that the 
calculations run quicker, leading to smoother motion.

Every element has an origin, the anchor that the transform functions execute from.
like an anchor point to anglgling

One common gotcha with transforms is that they don't work with inline 
elements in Flow layout.
The easiest fix is to switch it to use display: inline-block, 
or to use a different layout mode (eg. Flexbox or Grid).





*/

