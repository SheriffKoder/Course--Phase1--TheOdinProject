
/*
////2D Transforms

Almost all elements can have the transform property applied to it, 
with the exceptions being <col>, <colgroup>, and non-replaced inline elements. 

“Non-replaced” simply refers to elements whose content is contained within the HTML 
document (<span>, <b>, and <em>, for example), 

as opposed to a “replaced” element’s content being contained outside of the document 
(<a>, <iframe>, and <img>, for example).


rotate, scale, skew, translate




*/

.margin {
    margin: 0 0 100px 100px;
}

.box {
    background: black;
    height: 100px;
    width: 100px;
}

.skewXY {
    /* X and Y values respectively, if one then its X 
    also skewX, skewY separately */
    transform: skew(45deg, -0.5rad);

}


.mainContainer {
    height: 200px;
    width: 200px;
    border: 1px solid black;

    display: flex;
    align-items: center;
    justify-content: center;

    margin: 0 0 100px 100px;

}

.TranslateXY {
    transform: translate(20px, -33%);
}


/* order of chain will affect the display, 
as these two chains have the same values but different order 
composite transforms are effectively applied in order from right to left.

When an element is rotated before being translated, 
the translate direction is on the rotated axis.

transformation are always in the position defined by transform-origin 
(by default the center of the element)

the other difference with the left to right version is 
that you use a fixed system of coordinates/angles.

consider making use of the prefers-reduced-motion media feature — 
use it to write a media query that will turn off animations if the user 
has reduced animation specified in their system preferences.

*/

.TranslateChain1 {
    transform: skew(45deg, -0.5rad) translate(20px, 33%);
}


.TranslateChain2 {
    transform: translate(20px, 33%) skew(45deg, -0.5rad) ;
}




/* transformation example of ltr and rtl
The left element is using a left to right progression and the right one a right 
to left progression. Note how the corners of the left one are following 
an elliptical path and how the shape is not preserved during the rotation.
*/
.object
{
  width: 100px; height: 100px;
  background: rgb(114,34,34);
  animation: ltr 5s infinite;
}
.object2 {
    animation-name: rtl;
}

@keyframes ltr
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(.5) rotate( 0deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}
@keyframes rtl
{
  from, 10% { transform: scaleY(1 ) rotate( 0deg); }
  40%       { transform: scaleY(1 ) rotate(45deg); }
  70%, to   { transform: scaleY(.5) rotate(45deg); }
}



/*
//// 3D transforms

to perceive a 3D effect on some of these function values
perspective is required

This is the transform function value to set the distance 
from the user to the z = 0 plane:
viewing it from a specific distance on the z-axis

perspective must be declared first (leftmost) 
when there are multiple transform function values

you can use the transform property to move and rotate objects in a 3D space 
(with the X, Y, and Z axes), then use perspective to control depth.


*/

.perspective {
    transform: perspective();

}


/*////////////////////////////////////////////////////////////////////////*/
/* the basics of perspective 
the z-axis becomes effective when perspective is used

body {
  font-family: 'Anton', sans-serif;
  background-color: #eee;
  color: #333;
  min-height: 100vh;
  display: -webkit-box;
  display: flex;
  -webkit-box-pack: center;
          justify-content: center;
  align-content: center;
  -webkit-box-align: center;
          align-items: center;
  flex-wrap: wrap;
}

#axesZ:checked ~ .container > .square {
  -webkit-animation: moveOnZ 2s infinite ease-in-out alternate;
          animation: moveOnZ 2s infinite ease-in-out alternate;
}

#axesZ:checked ~ .options > label.axesZ {
  background-color: greenyellow;
}

@-webkit-keyframes moveOnZ {
@keyframes moveOnZ {
  from {
    -webkit-transform: translateZ(-50px);
            transform: translateZ(-50px);
  }
  to {
    -webkit-transform: translateZ(50px);
            transform: translateZ(50px);
  }
}
label.usePerspective {
  display: block;
  text-align: center;
  padding: 0.5em 1em;
  border: 1px solid #777;
  border-radius: 4px;
  margin-top: 1.5em;
}

#usePerspective:checked ~ .container {
  -webkit-perspective: 240px;
          perspective: 240px;
}

#usePerspective:checked ~ .options label.usePerspective {
  background-color: greenyellow;
}

/////////////////////////////////////////////////////////////

#axesX:checked ~ .container > .square {
  -webkit-animation: rotateOnX 4s infinite linear;
          animation: rotateOnX 4s infinite linear;
}

#axesX:checked ~ .options > label.axesX {
  background-color: greenyellow;
}

@-webkit-keyframes rotateOnX {
  to {
    -webkit-transform: rotateX(360deg);
            transform: rotateX(360deg);
  }
}



moving: translate  (perspective in Z)
flipping: rotate (perspective in X Y)



The perspective-origin property determines the position from which 
you are “looking” at an object. If the origin is centered (which is the 
default) and the object is moved to the right, it will seem like you are 
looking at it from the left (and vice versa).

When the origin is set to the side, it’s like you are “looking” at the object 
from that side. The bigger the value, the further aside it will look.


//behaves according to the perspective rules assigned to the parent element.
.container {
  width: 200px;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  display: -webkit-box;
  display: flex;
  -webkit-box-align: center;
          align-items: center;
  -webkit-perspective: 240px;
          perspective: 240px;
}

//moving from side to side rotated side
.square {
  width: 100px;
  height: 100px;
  background-color: green;
  -webkit-transform: rotateY(90deg);
          transform: rotateY(90deg);
}

.containerA > .square {
  -webkit-animation: moveSquare 4s infinite ease-in-out alternate;
          animation: moveSquare 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveSquare {
  from {
    -webkit-transform: translateX(-100px) rotateY(90deg);
            transform: translateX(-100px) rotateY(90deg);
  }
  to {
    -webkit-transform: translateX(100px) rotateY(90deg);
            transform: translateX(100px) rotateY(90deg);
  }
}


//while having rotateY 90, can view from different angles using origin

.containerB {
  -webkit-animation: moveOrigin 4s infinite ease-in-out alternate;
          animation: moveOrigin 4s infinite ease-in-out alternate;
}

@-webkit-keyframes moveOrigin {
  from {
    -webkit-perspective-origin: left;
            perspective-origin: left;
  }
  to {
    -webkit-perspective-origin: right;
            perspective-origin: right;
  }
}






When rotating an object, its coordinate system is transformed along with the object.
When translating an object, it moves relative to its own coordinate system (rather than its parent’s coordinates).
The order in which these values are written can (and will) change the end result.


//rotation order explaination, if order changes, output is different
.squareA {
  -webkit-animation: sqrA 4s infinite ease-in-out;
          animation: sqrA 4s infinite ease-in-out;
}

@-webkit-keyframes sqrA {
  0%, 10% {
    -webkit-transform: none;
            transform: none;
  }
  50% {
    -webkit-transform: rotate(30deg);
            transform: rotate(30deg);
  }
  90%, 100% {
    -webkit-transform: rotate(30deg) translateX(140px);
            transform: rotate(30deg) translateX(140px);
  }
}






.container {
  position: relative;
  width: 100%;
  height: 200px;
  border: 1px solid #fff;
  border-radius: 4px;
  margin: 0.5em auto;
  -webkit-perspective: 420px;
          perspective: 420px;
  -webkit-transform-style: preserve-3d;
          transform-style: preserve-3d;
}

//  left: calc(50% - 50px);

//moving around itself
@-webkit-keyframes sqrA {
  from {
    -webkit-transform: translateX(120px) rotateY(0deg);
            transform: translateX(120px) rotateY(0deg);
  }
  to {
    -webkit-transform: translateX(120px) rotateY(360deg);
            transform: translateX(120px) rotateY(360deg);
  }
}

//moving around the axis, (can use that 180 degree on click to show new box ?)
@keyframes sqrB {
  from {
    -webkit-transform: rotateY(0deg) translateX(120px);
            transform: rotateY(0deg) translateX(120px);
  }
  to {
    -webkit-transform: rotateY(360deg) translateX(120px);
            transform: rotateY(360deg) translateX(120px);
  }
}



// we could simply change the values themselves to get the desired result 
instead of changing the order of the values.



//The transform-style property has two values: 

flat (default)
preserve-3d:
It tells the sides of the cube (the child elements) to be positioned 
in the same 3D space as the cube

“copies” the cube perspective to its children (the sides) and allows 
us to rotate just the cube, so we don’t need to animate each side separately.

It displays the child elements according to their position in the 3D space, 
regardless of their place in the DOM.

//////////////////////////////////////////////////////////////////////////




//////////////////////////////////////////////////////////////////////////

The rotate3d() function rotates the element along the x, y, and z axes 
using the angle provided as an argument.
rotate3d(x, y, z, a)

transform: rotate3d(0);
transform: rotate3d(2, -1, -1, -0.2turn);
transform: rotate3d(0, 1, 0.5, 3.142rad);
transform: rotate3d(1, 1, 1, 45deg);

Is an <angle> representing the angle of the rotation. A positive angle 
denotes a clockwise rotation, a negative angle a counter-clockwise one.
deg, Degrees. There are 360 degrees in a full circle.
grad, Gradians, also known as "gons" or "grades" (although these aren't valid unit identifiers — you should still use grad as the unit identifier). There are 400 gradians in a full circle.
rad, Radians. There are 2Ï€ radians in a full circle.
turn, Turns. There is 1 turn in a full circle.


The default origin for the rotation is 50% 50%. You can use transform-origin 
to adjust the origin of the transformation:

  .rotated {
    transform-origin: 90% 90%;
    transform: rotate3d(1, -5, 1, -60deg);
  }





Note: scaleZ(sz) is equivalent to scale3d(1, 1, sz).

//translateZ and perspective work together
.moved {
  transform: perspective(500px) translate3d(10px, 0, 100px);
  background-color: pink;
}




The matrix() function is an alternative to the two-dimensional transform 
functions rotate(), skew(), scale(), and translate().
use the matrix() function instead of those functions.
matrix() for 2D transforms, matrix3d() for 3D transforms

transform: matrix(0.707107, 0.707107, -0.707107, 0.707107, 150, 0);

Any time you do a CSS transform, you're affecting the matrix. 
Even if you use another function such as rotate(), you're still affecting 
the matrix. The matrix determines the coordinates of the element — 
its position, size, orientation, etc.

matrix(a, b, c, d, e, f)
a, d
The arguments a and d represent how the element is scaled in the x and y direction respectively (just like in scale(a, d)).
b, c
The arguments b and c represent how the element is skewed (just like in skew(b, c)).
e, f
The arguments e and f represent how the element is translated in the x and y direction respectively (just like in translate(e, f)).

//Both lines have the same result
scale(2, 3);
matrix(2, 0, 0, 3, 0, 0);

https://css-tricks.com/how-css-perspective-works/
https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d

Fortunately, there are other options for getting the applicable arguments for the matrix() function:

One option is to create the transform using the various functions, then get the computed value from your browser's developer tools.
Another option is to use the Window.getComputedStyle() method to retrieve the computed value of the transform function.

//////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////
Rendering Performance
Users notice if sites and apps don't run well, so optimizing rendering performance is crucial!

Users of today’s web expect that the pages they visit will be interactive and 
smooth and that’s where you need to increasingly focus your time and effort. 
Pages should not only load quickly, but also run well; scrolling should be 
stick-to-finger fast, and animations and interactions should be silky smooth.

Most devices today refresh their screens 60 times a second. 
If there’s an animation or transition running, or the user is scrolling 
the pages, the browser needs to match the device’s refresh rate and put up 
1 new picture, or frame, for each of those screen refreshes.

It doesn’t have to be JavaScript that triggers a visual change, 
though: CSS Animations, Transitions, and the Web Animations API 
are also commonly used.


The key benefit of using transform is that it occurs during composition. 
This makes it cheaper to use compared to many other CSS properties.

You can see a table of what triggers are executed with each CSS property here.
https://web.archive.org/web/20220727225220/https://csstriggers.com/


A graphics processing unit (GPU) is a specialized electronic circuit designed 
to manipulate and alter memory to accelerate the creation of images in a frame 
buffer intended for output to a display device.

//////////////////////////////////////////////////////////////////////////







When we use a percentage value in translate, that percentage refers to the 
element's own size, not the available space within the parent container.
wether height or width

 .dialog-content {
    position: relative;
  }

  .close-btn {
    position: absolute;
    top: 0;
    right: 0;
    transform: translateY(-100%);
  }


With the magic of calc, we can even mix relative and absolute units:
transform: translateX(calc(1% + 0px));


The text scales up and down with the element
scaling the entire element

With transforms, we can skip a bunch of steps. This means that the 
calculations run quicker, leading to smoother motion.

Every element has an origin, the anchor that the transform functions execute from.
like an anchor point to angling

One common gotcha with transforms is that they don't work with inline 
elements in Flow layout.
The easiest fix is to switch it to use display: inline-block, 
or to use a different layout mode (eg. Flexbox or Grid).









//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
/* Transition




button {
  border: 1px solid black;
  border-radius: 5px;
  padding: 2% 5% 2% 5%;
  background-color: white;
  color: white;
  transition-property: background-color;
  transition-duration: 1s;
  transition-timing-function: ease-out;
  transition-delay: 0.25s;
}

button:hover {
  background-color: black;
  cursor: pointer;
}


transition duration: gradually happen over this period
transition timing function, ease-out, the color change will be faster at
the start than at the end of the transition


you can also trigger transitions by adding or removing classes with JavaScript. 
For example, clicking a button could append the “open” class to a dropdown menu, 
which would trigger the opening transition.


using a transform scenario forms a "stacking context"
when making many stacking contexts through various other means
when it comes to rendering our initial transform
we would repaint not only our div element
but also every element that is stacked on top of it in the stack context

if left, can cause transition to be slow

div {
  width: 100px;
  height: 100px;
  transition: transform 2s 1s; 
}

div:hover {
  transform: rotate(180deg);
}


second thing, keep your animations to only affect opacity and transform
if want to keep performance for animations on your web page
transition is an expensive operation
*/



.transitionButton {
    border: 1px solid black;
    border-radius: 5px;
    padding: 2% 5% 2% 5%;
    background-color: white;
    color: white;

    /*equivalent to   
    transition: background-color 1s ease-out 0.25s;     */
    transition-property: background-color;
    transition-duration: 1s;
    transition-timing-function: ease-out;
    transition-delay: 0.25s;
  }
  
  .transitionButton:hover {
    background-color: black;
    cursor: pointer;
  }


/*
//////////////////////////////////////////////////////////////////////////////

CSS transition provide a way to control animation speed when changing CSS properties

implicit transitions: between two states
explicit: defining delay, duration, timing


Each property's animation type determines how values combine - 
interpolate, add, or accumulate - for this property. 
Transitions only involve interpolation, 
whereas animations may use all three combination methods.

Animation types
. not animatable
. discrete: property's values are not additive, swaps from start value
to end value at 50%
. by computed value: corresponding inivicial components of the computed values
are combined using the indicated procedure for that value type
.Repeatable list: 

Using animations with auto may lead to unpredictable results, 
depending on the browser and its version, and should be avoided


////transition-property
Specifies the name or names of the CSS properties to which transitions should be applied.
changes to all other properties occur instantaneously as usual.

transition-property: margin-right, color; //this shortens the box
transition-property: all;

/* Keyword values
transition-property: none;
transition-property: all;

/* <custom-ident> values
transition-property: test_05;
transition-property: -specific;
transition-property: sliding-vertically;

/* Multiple values
transition-property: test1, animation4;
transition-property: all, height, color;
transition-property: all, -moz-specific, sliding;


.target {
  font-size: 14px;
  transition-property: font-size;
  transition-duration: 4s;
}

.target:hover {
  font-size: 36px;
}




////transition-duration
Specifies the duration over which transitions should occur. 
You can specify a single duration that applies to all properties during the 
transition, or multiple values to allow each property to transition over a 
different period of time.

If the number of specified durations is less than in the master list, 
the user agent repeats the list of durations. If the number of specified 
durations is more than in the master list, the list is truncated to the 
right size. In both the cases, the CSS declaration stays valid.

//both properties have different times
transition-duration: 3s, 1s;
transition-property: margin-right, color;

A time of 0s indicates that no transition will happen, default


////transition-timing-function
<easing-function> CSS data type denotes a mathematical function that describes 
the rate at which a numerical value changes.
This lets you vary the animation's speed over the course of its duration.
It may also be used to interpolate between two colors in a color gradient.
for transition and animation properties

*so can play with gradient by 
/* linear function and keyword
/* linear(<list-of-points>)
linear(1, -0.5, 0);
linear;

/* cubic-bezier function and keywords
/* cubic-bezier(<x1>, <y1>, <x2>, <y2>)
cubic-bezier(0.42, 0.0, 1.0, 1.0);
ease;
ease-in;
ease-out;
ease-in-out;

/* steps function and keywords
/* steps(<number-of-steps>, <direction>)
steps(4, end);
step-start;
step-end;

cubic-bezier
x1, y1, x2, y2
defining the cubic Bézier curve. x1 and x2 must be in the range [0, 1], 
otherwise the value is invalid.

ease
Indicates that the interpolation starts slowly, accelerates sharply, 
and then slows gradually towards the end. This keyword represents 
the easing function cubic-bezier(0.25, 0.1, 0.25, 1.0). It is similar 
to ease-in-out, though it accelerates more sharply at the beginning.

ease-in
Indicates that the interpolation starts slowly, then progressively speeds up 
until the end, at which point it stops abruptly. This keyword represents 
the easing function cubic-bezier(0.42, 0.0, 1.0, 1.0).

ease-in-out
Indicates that the interpolation starts slowly, speeds up, and then slows down 
towards the end. This keyword represents the easing function 
cubic-bezier(0.42, 0.0, 0.58, 1.0). At the beginning, it behaves like the 
ease-in function; at the end, it is like the ease-out function.

ease-out
Indicates that the interpolation starts abruptly and then progressively 
slows down towards the end. This keyword represents the easing function 
cubic-bezier(0.0, 0.0, 0.58, 1.0).


number-of-steps
A strictly positive <integer>, representing the amount of equidistant treads 
composing the stepping function.


direction
One of the following keywords that indicate when the jumps occur:

jump-start denotes that the first step or jump happens when the interpolation begins.
jump-end denotes that the last step or jump happens when the interpolation ends.
jump-both denotes that jumps occur at both the 0% and 100% marks, effectively adding a step during the interpolation iteration.
jump-none denotes no jump on either end. Instead, holding at both the 0% mark and the 100% mark, each for 1/n of the duration.
start is the equivalent of jump-start.
end is the equivalent of jump-end. This is the default.


step-start
Indicates that the interpolation jumps immediately to its final state, 
where it stays until the end. This keyword represents the easing 
function steps(1, jump-start) or steps(1, start).

step-end
Indicates that the interpolation stays in its initial state until the end, 
at which point it jumps directly to its final state. 
This keyword represents the easing function steps(1, jump-end) or steps(1, end).




//Linear easing function
linearly between its points, allowing you to approximate more complex animations 
like bounce and elastic effects
A typical use of the linear() function is to provide many points to create 
the illusion of a curve.

When you define the linear() function, you specify the linear easing points 
as a list, as in, linear(0, 0.25, 1). This linear() function produces an 
easing function that moves linearly from 0, to 0.25, then to 1.

Consider another example of the function: linear(0, 0.25 75%, 1). 
This produces a linear easing function that spends 75% of the time 
transitioning from 0 to .25 and the last 25% transitioning from .25 to 1.

The linear keyword produces a linear() function with two points. 
This is equivalent to the easing function cubic-bezier(0.0, 0.0, 1.0, 1.0).


//Cubic Bézier easing function
cubic-bezier subset of easing functions are often called "smooth" easing 
functions because they can be used to smooth down the start and end of 
the interpolation.
A cubic Bézier curve is defined by four points: P0, P1, P2, and P3.
P1/P2 0->1.0 can be more (jump)
certrain properties like color clip at 0->255 for above and below values
whole property ignored if invalid cubic-bezier is specified


//Step easing function
divides the domain of output values in equidistant steps.
sometimes also called staircase functions.

steps(2, jump-start)
steps(2, start)

steps(4, jump-end)
steps(4, end)

steps(5, jump-none)

steps(3, jump-both)

step-start and step-end;



*/