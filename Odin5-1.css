/*/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
/*

Introduction To Web Accessibility
a11y friendly concepts
important to keep in mind when developing a website.

When you develop a website, you’re developing it for users, and you need 
that website to actually be usable by them.

depending on the country, there could actually be laws requiring accessibility 
to be implemented.


Web accessibility means that websites, tools, and technologies are designed 
and developed so that people with disabilities and other circumstantial 
limitations can use them with as few barriers as possible.

-visual/hearing problems = audio/captions, text size/audio adjustments, signs
-arm usage circumstances
-using a phone outside on a bright day or noisy place
-slow bandwidth
-not tech savy/computer skills
-older people
-use duration
-ADHD, understanding complex concepts, anxiety, memory,
-migraines, reaction to visual flickering or audio signals at certain frequencies or pattenrs
-un ability to use parts of body to pain etc.
-bright color sensitivity, color blindness, 
-vision, partial sight, not sharp, tunnel vision, only edge seeing, clouded vision


Depending on the individual needs, people with cognitive, learning, and neurological disabilities often rely on:

Clearly structured content that facilitates overview and orientation;
Consistent labeling of forms, buttons, and other content parts;
Predictable link targets, functionality, and overall interaction;
Different ways of navigating websites, such as hierarchical menu and search;
Options to suppress blinking, flickering, flashing, and otherwise distracting content;
Simpler text that is supplemented by images, graphs, and other illustrations;

Complex navigation mechanisms and page layouts that are difficult to understand and use.
Complex sentences that are difficult to read and unusual words that are difficult to understand.
Long passages of text without images, graphs, or other illustrations to highlight the context.
Moving, blinking, or flickering content, and background audio that cannot be turned off.
Web browsers and media players that do not provide mechanisms to suppress animations and audio.
Visual page designs that cannot be adapted using web browser controls or custom style sheets.

People with physical disabilities rely on keyboard support to activate functionality 
provided on web pages. They may need more time to type, click, or carry out other 
interaction, and they may type single keystrokes in sequence rather than typing 
simultaneous keystrokes

Providing large clickable areas, enough time to complete tasks, 
and error correction options for forms are important design aspects. 

visible indicators of the current focus, and mechanisms to skip over blocks, 
such as over page headers or navigation bars. 

Images, controls, and other structural elements that do not have equivalent text alternatives.
Inconsistent, unpredictable, and overly complicated navigation mechanisms and page functions.
Text and images with insufficient contrast between foreground and background color combinations.
Websites, web browsers, and authoring tools that do not support the use of custom color combinations.
Websites, web browsers, and authoring tools that do not provide full keyboard support.



Missing visual and non-visual orientation cues, page structure, and other navigational aids.
Inconsistent, unpredictable, and overly complicated navigation mechanisms and page functions.

Visual
Enlarging or reducing text size and images;
Customizing settings for fonts, colors, and spacing;
Listening to text-to-speech synthesis of the content;
Listening to audio descriptions of video in multimedia;
Reading text using refreshable Braille.


For these web browsing methods to work, developers need to ensure that the 
""presentation of web content is independent of its underlying structure"" and 
that the structure is correctly coded so that it can be processed and presented 
in different ways by web browsers and assistive technologies. For example, 
some people do not see the content and rely on lists, headings, tables, and 
other page structures to be properly coded so that they can be identified 
by web browsers and assistive technologies.



//////////////////////////////////////////////////////////////////////////////

Web accessibility is essential for people with disabilities and useful for all.

//Keyboard compatibility:
All functionality must be usable with the keyboard. That is, users can access 
and move between links, buttons, forms, and other controls using the Tab key 
and other keystrokes. Websites should not require a mouse; for example, pop-up 
calendars should also let users type in a date.

Ensure that the tab order is logical, to allow keyboard navigation around the 
content and controls. Provide a way for users to jump between blocks of content 
and controls.

//Video/animation Captions:


//Colors with Good Contrast:
color contrast between text color and the background color
technically called luminance contrast ratio
this includes text on images, icons, and buttons.

Also colors used to convey information on diagrams, maps, and other types of 
images must be distinguishable.


What are the additional benefits?
Content works in different lighting conditions, such as sunlight and glare.
Content is easier to read by everyone, including those who do not have specific visual conditions.

Select text and background colors that provide sufficient contrast. 
There are tools to help check and select appropriate color combinations. 
This is ideally done during the early design stage and the selection of 
color palettes. While some people need high contrast, some people are 
sensitive to brightness and need to change the colors.

important enough to be seen and needs to be clear

//customizable text:
Some users need to be able to change the way text is displayed so that they 
can read the text. This includes changing the size, spacing, font, color, and 
other text properties. When users change these properties, no information or 
functionality should be lost, and the text should re-flow so users don’t have 
to scroll horizontally to read sentences. Text customization is more than the 
zoom functionality, which only changes the text size.

Content is more adaptable to smaller and larger screen sizes.
Content is more adaptable when translated, since words and sentences are 
different lengths in different languages.

Content must be properly designed and coded so that it can adapt to different 
customization settings. This includes using relative rather than absolute units 
for the size of fonts, controls, and other objects. Applications should use the 
operating system and web browser text settings. Websites and applications could 
also provide information to help users change their settings

//Clear Layout and Design:
The different parts of a web page must be easy to locate and identify. 
This includes navigation menus, links, and text sections. 
These should be at predictable locations and consistently identified. 
Also form labels and instructions have to be clearly associated with their controls.

Content is more usable for people who are new to the particular website or application.
Content is more usable for mobile device users who are seeing it on smaller screens, 
especially if they are in a hurry or distracted.
Content and functionality is easier to locate and identify by most users.

Design clear structure, both visually and through the markup. For example, 
make it easy to distinguish sections such as navigation, group related controls 
in a form, and provide headers to identify groups of information. 
Provide consistent presentation and behavior of web pages across a website.


//Speech recognition
Speech recognition can be used for dictating text in a form field, as well as 
navigating to and activating links, buttons, and other controls. 
Most computers and mobile devices today have built-in speech recognition 
functionality. Some speech recognition tools allow complete control over computer 
interaction, allowing users to scroll the screen, copy and paste text, activate 
menus, and perform other functions.

Content must be properly designed and coded so that it can be controlled by speech. 
"keyboard compatibility" is the basis for such coding. In addition, labels and 
identifiers for controls in the source code need to match their 
visual presentation, so that it is clear which speech command will activate 
a control.


//text to speech
 Screen readers provide important functionality such as navigating through headings, 
 speaking image alternatives, and identifying internal and external links. 
 They can also highlight the text as it is being read aloud for people to see 
 and hear the content at the same time. Content must be coded properly so that 
 all of the functionality of the text-to-speech software works with the content.

Content can be read aloud for people

Use semantic HTML markup for structures such as headings, paragraphs, lists, forms, 
and tables. Provide text alternatives for images, icons, and other non-text content. 
Ensure keyboard compatibility, and ensure that text information is understandable 
without the visual context.


//understandable content
Content must be easy to follow and understand for many users. For most content, 
this means simply avoiding overly complex sentences and jargon, and providing 
clear layout and design. For some complex content such as medical information, 
separate, easy-to-read information may be necessary.

Provide structure using headings, lists, and spacing.
Provide illustrations that clarify the content, when helpful.
Provide clear layout and design with consistent orientation and navigation cues.


//Large Links, Buttons, and Controls:
The area for clicking and tapping controls must be large enough for people to 
activate them. This includes links, buttons, checkboxes, and other controls. 

Small controls, and controls that are placed too close to each other, 
are difficult for many people to use.

Content is more usable on touch screens, especially on smaller mobile devices.
Content is more usable in situations where the device cannot be held steady.

Design large controls or activation areas around the controls. (Increasing the 
font size of the control sometimes isn’t enough.) Provide adequate separation 
between selectable controls. Provide labels for controls, which enlarges the 
activation area in many browsers because the label for checkboxes and option 
buttons is also clickable.


//Notifications and Feedback
For example, users need confirmation messages when actions are completed, 
such as when forms are submitted. Also, error messages must provide clear directions 
rather than confuse users.

Content is less confusing and daunting to everyone, regardless of skills.


//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////
resolve accessibility by innovation, not litigation
wider range of people use these devices, regardless of ability.

contrast minimums, auto-complete, voice control, artificial intelligence, auto captioning

At least one billion people – 15% of the world’s population – have a recognized disability15

Accessible design considerations often lead to improvements in general 
customer experience and loyalty.

all over the world, governments and regulators began to mandate laws and policies 
that strengthen the rights of people with disabilities to participate in online 
digital information and services.

The website must be made accessible to “individuals with disabilities 
who use computers, laptops, tablets, and smartphones.”

modified customized to be used to maintain , improve functional capabilities of 
individuals with disabilities

*make an assistive design list
*assistive drop down menu options

minimal design to minimize cognitive load

when you design for disability first, 
you ofter provide better usage for all users to benefit from
think from different sides

//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////

goes over different ways to help make websites more accessible
Web Content Accessibility Guidelines (WCAG).


////
organized around four, core principles (POUR) that should be kept in mind when 
implementing any sort of accessibility feature:

.Perceivable: Users must be able to perceive the information or user 
interfaces being presented. For example, light text on a light background 
could be difficult for some users with a visual impairment to perceive.

.Operable: Users must be able to operate any user interfaces or navigation, 
and interfaces cannot require an interaction which the user cannot perform. 
A navigation bar with drop-down menus that only expand when a mouse cursor 
hovers over them, for example, would not be operable by keyboard users giving 
those menu items focus.

.Understandable: Users must be able to understand any information or user 
interface that is presented to them. For example, if a user tried submitting a 
form and received an error such as “Error 113: Bad data”, they wouldn’t be able 
to understand what the error actually means or how to fix whatever caused the error.

.Robust: Content must be accessible by current assistive technologies and 
other user agents, and must remain accessible as those technologies advance.


Conformance Levels
Level A, or essential support, is the minimum level of conformance for the WCAG.
Level AA, or ideal support, is the level many organizations strive for. Meeting 
this level also requires meeting Level A.
Level AAA, or specialized support, isn’t recommended for entire sites to meet in 
full, as some content may make it impossible to meet this conformance level. 
Meeting this level would require also meeting both Level A and Level AA.



(Before) Implementing Accessibility
The first thing to keep in mind is that no site will ever be 100% accessible, 
so don’t try to aim for such an impossible goal.
Sometimes the purpose or concept of a site even requires some things to not 
be accessible in certain ways.


providing a single shared standard for web content accessibility that meets the 
needs of individuals, organizations, and governments internationally.

Web “content” generally refers to the information in a web page or web application, including:
.natural information such as text, images, and sounds
.code or markup that defines structure, presentation, etc.

a website that meets WCAG 2.1 should meet the requirements of policies that 
reference WCAG 2.0




Perceivable:
Provide text alternatives for non-text content.
Provide captions and other alternatives for multimedia.
Create content that can be presented in different ways, including by assistive technologies, without losing meaning.
Make it easier for users to see and hear content.

Operable:
Make all functionality available from a keyboard.
Give users enough time to read and use content.
Do not use content that causes seizures or physical reactions.
Help users navigate and find content.
Make it easier to use inputs other than keyboard.

Understandable:
Make text readable and understandable.
Make content appear and operate in predictable ways.
Help users avoid and correct mistakes.

Robust:
Maximize compatibility with current and future user tools.

3:1 color contrast minimum



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Accessible Colors




White text on a white background would have lowest ratio (1:1), 
while black text on a white background would have the highest (21:1)
Contrast ratios refer to both normal text as well as images of text.

There are two different conformance levels for contrast ratios, 
both of which have rules for normal text and large text.

Normal text is defined as text with a font size that’s less than 
18 points/24px (or less than 14 points/18.66px for bold text)

Level AA (minimum) requires a contrast ratio of at least 4.5:1 for normal text and 3:1 for large text.
Level AAA (enhanced) requires a contrast ratio of at least 7:1 for normal text and 4.5:1 for large text.

Both conformance levels have exceptions that 
don’t need to follow the contrast ratio rules:

-Incidental text, such as text that just happens to be within an image 
that has other significant visual content, or text that is purely decorative.

-Text that is part of an inactive or disabled user interface component, 
such as a button that is disabled and has a lowered opacity.

how to check:
https://webaim.org/resources/contrastchecker/
Chrome>element picker>element's accessibility contrast ratio

Instead of only using color, your form could indicate all required fields 
with red text and an asterisk:


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Keyboard Navigation

some users rely on using a keyboard or another assistive technology that can 
simulate keyboard inputs, such as voice recognition software.

if you ever need to use an element that isn’t focusable or doesn’t have any 
event handling by default, then you need to add both of those functionalities 
in manually.

//HTML: div and span aren't focusable but we can make them so
<!-- The `tabindex` attribute makes the `<div>` elements focusable. -->
<div class='button-container'>
  <div class='rock button' tabindex='0'>Rock</div>
  <div class='paper button' tabindex='0'>Paper</div>
  <div class='scissors button' tabindex='0'>Scissors</div>
</div>

//JS: We also need to manually add in event handling for both mouse and keyboard events.
const buttons = document.querySelectorAll('.button');

function nameAlerter(e) {
  if (e.type === 'click' || e.key === ' ' || e.key === 'Enter') {
    alert(e.target.textContent);
  }
}

buttons.forEach(button => {
  button.addEventListener('click', nameAlerter)
  button.addEventListener('keydown', nameAlerter)
})


<button>
using the <button> element provide the context screen reader users need
focusable and have event handling for keyboards by default
default: pressing the “space” or “enter” keys on a keyboard when a <button> 
has focus will trigger the “click” event.


//changing focus behavior
//adding your own focus styles, to enhance scale, outline to a link, 
increasing border width, input opacity
//Completely removing focus styles can make a page impossible for 
keyboard users to navigate and operate

*:focus {
  outline: xxx;
  border: xxx;
}


////Tab order
//Sometimes you may find it necessary to either change the visual order of 
elements on a page using CSS (the float or order properties, for example), 
or the tab order of elements themselves using the tabindex attribute. 

//If the tab order is different from the visual order, users could be left 
confused or frustrated trying to navigate the page with a keyboard,

//The best way to avoid this issue is to just place elements in your HTML file 
in the order that you want them to actually receive focus.


////Hidden content
hide some content until a specific event occurs
such as a user clicking on a button to open a menu or a modal box
should be in this case visually hidden and also hidden from assistive technologies
until that content is meant to be visible

by giving a tabindex of value -1 (prevents an element from receiving focus via the keyboard)
and can still give it focus though javascript's focus
document.querySelector('[tabindex="-1"]').focus()

While this fixes the issue for keyboard users, other assistive technologies 
would still have access to and could still announce this hidden content.
so a better solution is giving 
the container for the hidden content itself
display: none or visibility: hidden

and removing or overriding that property when it’s meant to be visible.
removes the menu items from the tab order, also prevents assistive technologies
from announcing them


//////////////////////////////////////////////////////////////////////////////
focus: selecting an element and directing all the keyboard events to that element

tab (focus forward)
shift tab (focus back)
up/down, type first letter to access dropdown

focusable: inputs select button

not all elements are focusable

html dictates focus order
so changing place by css wont affect the focus order


tabindex attr to make sure items are focusable
starting 0
directing all the keyboard events to that element

keep to tabindex of 0, to keep the html order
higher than 0 can cause focus to bounce around
//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////

On most pages, keyboard and screen reader users must navigate a long list 
of navigation links and other elements before ever arriving at the main content.

Skip navigation links are useful to give screen reader and keyboard users 
the same capability of navigating directly to the main content.

The idea is simple enough: provide a link at the top of the page that, 
when activated, jumps the user to the beginning of the main content area.

creating a skip navigation link
put it at or near the top of the page in regular text.
The key is to make sure the link is one of the first items that screen readers hear.
The link must also be apparent to be helpful.

<body>
<a href="#maincontent">Skip to main content</a>
...
<main id="maincontent">
<h1>Heading</h1>
<p>This is the first paragraph</p>

we recommend creating a link that is hidden until to the user 
navigates to it with a keyboard.
.be hidden by default
.be accessible to keyboard navigation
.become prominently visible when it is focused
.properly set focus to the main content area when activated

Some techniques, such as hiding the skip link with CSS display:none or 
the hidden attribute, will remove the link from keyboard navigation making 
it inaccessible to all users. Making the link the same color as the background 
or fully transparent, sizing the link to 0 pixels, or placing it on a one-pixel 
transparent image can also pose accessibility issues.

> Skip to main content

In most cases, a single skip link is sufficient. For pages that have very 
few navigable items preceding the main content, a skip link may not be necessary at all

Implementing proper heading structures (especially starting the main content 
with an <h1>) and regions (especially <nav> and <main>) is a vital aspect of 
keyboard accessibility.


////Not recommended and recommended styles
//display:none or visibility: hidden
These styles will hide content from all users. The content is removed from 
the visual flow of the page and is ignored by screen readers

//hidden attribute
The HTML hidden attribute is relatively new and not supported on older browsers

//An element with no height or width, whether defined in HTML or CSS, 
is typically removed from the flow of the page, so most screen readers will 
not read it. 

//Content styled with font-size:0px or line-height:0 may work, though the 
elements would still take horizontal space on the screen. All these 
techniques may result in search engine penalties as they may be interpreted as 
malicious.

//text-indent: -10000px;
This approach moves the content to the left 10000 pixels - thus off the visible 
screen. Screen readers will still read text with this style.


//recommended
.sr-only {  //screen reader only
position:absolute;  //remove from text flow
left:-10000px;
top:auto;   //same vertical place
width:1px;
height:1px;
overflow:hidden; //hide everything that does not fit into the 1px x 1px
}


Navigable elements, such as links and form controls, should not be hidden 
off-screen. They would still be navigable by sighted keyboard users, 
but would not be visible to them, unless they are styled to become 
visible when they receive keyboard focus.

A hidden, associated <label> element with "Search terms" (or similar) text
not all screen readers have sight problems


//skip links recommended
#skip a
{
position:absolute;
left:-10000px;
top:auto;
width:1px;
height:1px;
overflow:hidden;
}
 
#skip a:focus
{
position:static;
width:auto;
height:auto;
}

<div id="skip"><a href="#content">Skip to Main Content</a></div>
implementing CSS transitions to animate the focused "skip" link from above 
the top of the page (as opposed to off-screen left) to the top left corner of the 
page, then back above the page when focus is lost.






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Responsive Design



creating websites that respond to changes in browser size in order to create 
something that works on any device.

techniques

Lower end target: 320px
Higher end target: setting up a max-width for all of your content and then 
centering that on the page. 

how to completely rearrange items on a page based on screen size

A plain, naked, HTML site is perfectly responsive
until you change that with CSS

If you approach your project with this mindset and do your best to maintain 
that natural responsiveness, you might find that there isn’t that much extra 
you need to do to make your sites properly responsive.

tips you can use to maintain natural responsiveness.




////The Viewport Meta Tag
you should add this snippet into the <head> of your HTML file in just about 
every project you work on.
sets the initial width of the webpage to the size of the actual screen you’re 
viewing it on, and telling it not to zoom in or out.
<meta name="viewport" content="width=device-width, initial-scale=1">



////Avoid Fixed Width and Height
The number one enemy of flexibility is a fixed width on an element.
If you put width: 600px on anything, 
then it will never be able to shrink below that width, which ruins your chances 
of getting that thing to fit on most phone screens.

Likewise, sticking a fixed height on an element can cause issues if the contents 
of that element run out of room.


Obviously the context will determine what works in a given situation
but an easy fix in many cases is replacing 
"width or height with max-width or min-height"

min-width and max-height are also valid and may be useful depending on the context


//Avoid heights all together
In most cases, you should avoid setting a height altogether. 
There are some exceptions to this rule (headers and footers perhaps) 
but you should prefer using margin and padding to increase space around your 
content. Using margin and padding will keep your elements flexible no matter 
what the content inside does.

//Use flex and Grid
You’ve already learned about the relevant properties here, 
but things like flex-wrap and grid’s minmax, auto-fill and similar properties 
can make some impressively responsive layouts without much extra work.


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Viewport meta tag

The browser's viewport is the area of the window in which web content can be seen.
This is often not the same size as the rendered page

The viewport meta tag mitigates this problem of virtual viewport 
on narrow screen devices.

<meta name="viewport" content="width=device-width, initial-scale=1" />

width: 
controls the size of the viewport
can be pixels like 600px, 
or to the special value device-width
which is 100vw or 100% of the viewport width
min 1 max 10000
negative values are ignored

height:
same

initial-scale:
Controls the zoom level when the page is first loaded. 
Minimum: 0.1. Maximum: 10. Default: 1. 
Negative values: ignored.

minimum-scale:
Controls how much zoom out is allowed on the page. 
Minimum: 0.1. Maximum: 10. Default: 0.1. 
Negative values: ignored.

maximum-scale:
Controls how much zoom in is allowed on the page. 
Any value less than 3 fails accessibility. 
Minimum: 0.1. Maximum: 10. Default: 10. 
Negative values: ignored.

user-scalable: 
Controls whether zoom in and zoom out actions are allowed on the page.
Valid values: 0(no, against WCAG accessibility)
              1, 
              yes, or no. 

Usage of user-scalable=no can cause accessibility issues to users 
with visual impairments such as low vision. 
WCAG requires a minimum of 2× scaling; however, 
the best practice is to enable a 5× zoom.


interactive-widget: 
Specifies the effect that interactive UI widgets, 
such as a virtual keyboard, have on the page's viewports

Valid values: resizes-visual, resizes-content, or overlays-content. 
Default: resizes-visual.



////Screen density
screen resolutions hare high for smartphones now
small screen with resolutions upwards 1920x1080px (=400dpi)
because of this, many browsers can display their pages in a smaller 
physical size by translating multiple hardware pixels for each CSS pixel
this caused usability and readability problems on many touch-optimized websites

On high dpi screens, pages with initial-scale=1 will effectively be 
zoomed by browsers. Their text will be smooth and crisp, 
but their bitmap images may not take advantage of the full screen resolution. 
To get sharper images on these screens, web developers may want to design 
images – or whole layouts – at a higher scale than their final size 
and then scale them down using CSS or viewport properties

The default pixel ratio depends on the display density. 
On a display with density less than 200dpi, the ratio is 1.0. 
On displays with density between 200 and 300dpi, the ratio is 1.5. 
For displays with density over 300dpi, the ratio is the integer floor (density/150dpi). 
Note that the default ratio is true only when the viewport scale equals 1. 
Otherwise, the relationship between CSS pixels and device pixels 
depends on the current zoom level.


//Viewport width and screen width
Sites can set their viewport to a specific size. For example, the definition "width=320, initial-scale=1" can be used to fit precisely onto a small phone display in portrait mode. This can cause problems when the browser renders a page at a larger size. To fix this, browsers will expand the viewport width if necessary to fill the screen at the requested scale. This is especially useful on large-screen devices.

For pages that set an initial or maximum scale, this means the width property actually translates into a minimum viewport width. For example, if your layout needs at least 500 pixels of width then you can use the following markup. When the screen is more than 500 pixels wide, the browser will expand the viewport (rather than zoom in) to fit the screen:

<meta name="viewport" content="width=500, initial-scale=1" />
Copy to ClipboardCopy to Clipboard
Other attributes that are available are minimum-scale, maximum-scale, and user-scalable. These properties affect the initial scale and width, as well as limiting changes in zoom level.


//The effect of interactive UI widgets
Interactive UI widgets of the browser can influence the size of the page's viewports. 
The most common such UI widget is a virtual keyboard. To control which resize behavior 
the browser should use, set the interactive-widget property.

Allowed values are:

resizes-visual
The visual viewport gets resized by the interactive widget.

resizes-content
The viewport gets resized by the interactive widget.

overlays-content
Neither the viewport nor the visual viewport gets resized by the interactive widget.

When the viewport gets resized, the initial containing block also gets resized, 
thereby affecting the computed size of viewport units.


//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Using Percentages in CSS

in many of the places where you might want to reach for them, 
there is likely a better solution!


whatever you’re styling should look nice on the range of viewports 
and orientations that you intend to support.

common misconception
I want this thing to respond to the browser’s width or height, 
so what I need here is to make the dimensions of my element a percentage 
so that it’s flexible and responsive!

The truth: most elements are already responsive to the viewport, 
even without using percentages. Consider this code and the gif that follows.

Generally, things look nice when the margin outside of an element 
and the padding inside the element is either the same or related. 


You do not need the percentage rule to make this card responsive. 
If you simply remove the width rule, most html elements will expand horizontally 
to fill 100% of the horizontal space. 
(For what it’s worth, this behavior is not the same as using width: 100% 


//OK BUT I DON’T WANT IT TO BE FULL WIDTH.
but rather than using a percentage to define the width of the element, 
use a static margin.
and another margin on the media query for smaller screens

max-width so that the element won’t exceed a certain width even on huge screens. 
and good for wide screens
we can no longer rely on margin: auto to center it
but there are many ways to center things in CSS. like flexbox:

using something like height 100% to make a child component fill 
the entire height of its parent can be useful, as can width: 100% for elements 
that do not expand by default. 
(general rule: block-level elements expand, inline elements do not 
for a list of block-level and inline elements.)
//////////////////////////////////////////////////////////////////////////////







//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
minmax() in auto-fill repeating tracks

a grid that contains as many 200 pixel column tracks as will fit into the container 
with the remaining space shared equally between the columns.

In the minmax() function 
the first value is the minimum size I want my tracks to be, 
the second is the maximum. 
By using 1fr as the maximum value the space is equally distributed.

.boxes_wrapper {
    display: grid;
    grid-gap: 10px;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr) ) ;
}






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Responsive Images

images behave properly when resizing them with CSS.
how to serve up different images based on screen-size.

the main problem faced with responsive images is aspect-ratio
relationship between width and height
if shrink the width of an image on smaller screens
does not manipulate the height 
and the image will appear distorted

solution to retain its aspect ratio correctly
flexible width
height set to auto


not want an image to simply shrink in h and w
background-size, object-fit
provide a little more flexibility with how aspect-ratios are handled

background-position, background-size
properties work on elements with a background image
do not work on normal img tags

background-position: center
background-size: cover

object-fit
works similarly
but is meant for img tags
default value fil, which stretches the image to fit the dimensions
value cover, contain

For example, instead of just trusting object-fit to keep the subject of a photograph 
in frame, you could present a cropped version of it on smaller screens. 
There are two ways of achieving this, but the most flexible is using the <picture>


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
background-size: 
cover / contain / value.auto / w h (values)
given one value, height defaults to auto


/* Multiple backgrounds
background-size: auto, auto; /* Not to be confused with `auto auto`
background-size: 50%, 25%, 25%;
background-size: 6px, auto, contain;


contain
Scales the image as large as possible within its container without 
cropping or stretching the image. If the container is larger than the image, 
this will result in image tiling, unless the background-repeat property 
is set to no-repeat.

cover
Scales the image (while preserving its ratio) to the smallest possible size to 
fill the container (that is: both its height and width completely cover 
the container), leaving no empty space. If the proportions of the background 
differ from the element, the image is cropped either vertically or horizontally.

auto
Scales the background image in the corresponding direction 
such that its intrinsic proportions are maintained.

<length>
Stretches the image in the corresponding dimension to the specified length.
Negative values are not allowed.

<percentage>
Stretches the image in the corresponding dimension to the specified percentage 
of the "background positioning area". The background positioning area is 
determined by the value of background-origin (by default, the padding box). 
However, if the background's background-attachment value is fixed, 
the positioning area is instead the entire viewport. 
Negative values are not allowed.

A bitmap image (such as JPG) always has intrinsic dimensions and proportions.
SVG does not necessarily have intrinsic dimensions
If it has no dimensions or only one dimension, it may or may not have proportions.
CSS <gradient>s have no intrinsic dimensions or intrinsic proportions.

Background images created with the element() function use the intrinsic 
dimensions and proportions of the generating element.

<div class="tiledBackground"></div>

.tiledBackground {
  background-image: url(https://www.mozilla.org/media/img/logos/firefox/logo-quantum.9c5e96634f92.png);
  background-size: 150px;
  width: 300px;
  height: 300px;
  border: 2px solid;
  color: pink;
}
//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
background-position
sets the initial position for each background image
the position is relative to the position layer set by background-origin

background-position: top;
background-position: bottom;
background-position: left;
background-position: right;
background-position: center;

//percentage
background-position: 25% 75%;

//length values
background-position: 0 0;
background-position: 1cm 2cm;
background-position: 10ch 8em;

//Multiple images
background-position: 0 0, center;

//Edge offsets values
background-position: bottom 10px right 20px;
background-position: right 3em bottom 10px;
background-position: bottom 10px right;
background-position: top right 10px;

//global values
background-position: inherit;
background-position: initial;
background-position: revert;
background-position: revert-layer;
background-position: unset;


position
two non keyword values are used: first (horizontal position) second (vertical position)
if one value specified: the second value is assumed to be center
three or four values used: length-percentage values are offsets for the preceding keyword values

Note that: If one value is top or bottom, then the other value may not 
be top or bottom. If one value is left or right, then the other value 
may not be left or right. This means, e.g., that top top and left right 
are not valid.


//one value syntax
center
top, left, bottom, right, length/percentage etc.. the other dimension is then set to 50%


//two value syntax
one defines x the other defines y
The default value is left top or 0% 0%.

//three value syntax
The first value is one of the keyword values top, left, bottom, right, or center. 

If left or right are given here, then this defines X. 
If top or bottom are given, then this defines Y and the other keyword value defines X.

The <length> or <percentage> value, 
if it is the second value, is the offset for the first value. 
If it is the third value, it is the offset for the second value.

The combination of one keyword with two <length> or <percentage> values is not valid.


//four value syntax
first and third values are keyword values of top/left/bottom/right
if top/bottom then defines Y if left/right then defines X
and second/third are offsets of length/percentage for the first and third respectively


//percentages
The percentage offset of the given background image's position is relative to the container.
background-position: 25% 75% 
means the spot on the image that is 
25% from the left and 
75% from the top will be placed at the spot of the container


(container width - image width) * (position x%) = (x offset value)
(container height - image height) * (position y%) = (y offset value)


div {
  background-color: #ffee99;
  background-repeat: no-repeat;
  width: 300px;
  height: 80px;
  margin-bottom: 12px;
}

.examplethree {
  background-image: url("startransparent.gif"), url("catfront.png");
  background-position: 0px 0px, right 3em bottom 2em;
}


//////background-origin
property sets the background's origin from the border start
,inside the border, or inside the padding

background-origin: border-box;
background-origin: padding-box;
background-origin: content-box;

.box {
  margin: 10px 0;
  color: #fff;
  background: linear-gradient(
      90deg,
      rgba(131, 58, 180, 1) 0%,
      rgba(253, 29, 29, 0.6) 60%,
      rgba(252, 176, 69, 1) 100%
    ), radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 28%);
  border: 20px dashed black;
  padding: 20px;
  width: 400px;
  background-origin: padding-box, content-box;
  background-repeat: no-repeat;
}



//////object-fit
css property sets how the content of a replaced element
such as an <img> <video> should be resized to fit its container

object-fit: contain;
The entire object is made to fill the box, while preserving its aspect ratio
the object will be "letterboxed" if its aspect ratio does not match the aspect ratio of the box.

object-fit: cover;
The replaced content is sized to maintain its aspect ratio while filling the element's 
entire content box. If the object's aspect ratio does not match the aspect ratio of its box, 
then the object will be clipped to fit.

object-fit: fill;
The replaced content is sized to fill the element's content box. 
The entire object will completely fill the box. If the object's aspect 
ratio does not match the aspect ratio of its box, 
then the object will be stretched to fit.

object-fit: none;
The replaced content is not resized.

object-fit: scale-down;
The content is sized as if none or contain were specified, 
whichever would result in a smaller concrete object size.
//////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
Responsive images

images on a narrow width will take much of the height
display a cropped version of the image which displays the important details of the image

mobile users don't want to waste bandwidth by downloading a large image 
intended for desktop users

To make things more complicated, some devices have high resolution screens 
that need larger images than you might expect to display nicely.

Responsive image technologies were implemented recently to solve the problems 
indicated above by letting you offer the browser several image files, either 
all showing the same thing but containing different numbers of pixels 
(resolution switching), or different images suitable for different space 
allocations (art direction).


CSS arguably has better tools for responsive design than HTML, and we'll 
talk about those in a future CSS module.


<img
  srcset="elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w"
  sizes="(max-width: 600px) 480px,
         800px"
  src="elva-fairy-800w.jpg"
  alt="Elva dressed as a fairy" />


srcset defines the set of images we will allow the browser to choose between, 
and what size each image is.


srcset: img file name, The image's intrinsic width in pixels (480w)
sizes: The width of the slot the image will fill when the media condition is true (480px)


//look at what the viewport is
document.querySelector('html').clientWidth)


Older browsers that don't support these features will just ignore them. 
Instead, those browsers will go ahead and load the image referenced in the 
src attribute as normal.


In the <head> of the example linked above, you'll find the line 
<meta name="viewport" content="width=device-width">: this forces mobile 
browsers to adopt their real viewport width for loading web pages 
(some mobile browsers lie about their viewport width, and instead 
load pages at a larger viewport width then shrink the loaded page down, 
which is not very helpful for responsive images or design).


//Resolution switching: Same size, different resolutions
If you're supporting multiple display resolutions, 
but everyone sees your image at the same real-world size on the screen, 
you can allow the browser to choose an appropriate resolution image by using srcset 
with x-descriptors and without sizes — a somewhat easier syntax! 
You can find an example of what this looks like in srcset-resolutions.html 
(see also the source code):


<picture>
  <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg" />
  <source media="(min-width: 800px)" srcset="elva-800w.jpg" />
  <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva" />
</picture>

When the browser starts to load a page, it starts to download (preload) any 
images before the main parser has started to load and interpret the page's 
CSS and JavaScript. That mechanism is useful in general for reducing page 
load times,

